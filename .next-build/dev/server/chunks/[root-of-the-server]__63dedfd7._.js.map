{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jurit/OneDrive/Desktop/sito%20upscale/pages/api/tools/translate-document.js"],"sourcesContent":["import formidable from 'formidable';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport mammoth from 'mammoth';\r\nimport PDFDocument from 'pdfkit';\r\nimport OpenAI from 'openai';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const config = {\r\n    api: {\r\n        bodyParser: false,\r\n    },\r\n};\r\n\r\n// Funzione per estrarre testo da diversi formati\r\nasync function extractText(filePath, mimeType, originalFilename) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (mimeType === 'application/pdf' || ext === '.pdf') {\r\n        // Estrazione testo da PDF usando pdf-parse (CommonJS via dynamic require)\r\n        try {\r\n            // In ambiente ESM di Next.js, usa createRequire per caricare moduli CommonJS\r\n            const { createRequire } = await import('module');\r\n            const require = createRequire(import.meta.url);\r\n            const pdfParse = require('pdf-parse');\r\n            \r\n            const dataBuffer = fs.readFileSync(filePath);\r\n            const result = await pdfParse(dataBuffer);\r\n            const text = (result && result.text) ? result.text.trim() : '';\r\n\r\n            if (!text || text.length === 0) {\r\n                throw new Error('Il PDF non contiene testo estraibile. Potrebbe essere composto solo da immagini.');\r\n            }\r\n\r\n            return text;\r\n        } catch (error) {\r\n            console.error('Errore estrazione PDF:', error);\r\n            throw new Error('Errore durante l\\'estrazione del testo dal PDF. Assicurati che il PDF contenga testo selezionabile.');\r\n        }\r\n    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || ext === '.docx') {\r\n        const result = await mammoth.extractRawText({ path: filePath });\r\n        return result.value;\r\n    } else if (mimeType === 'application/msword' || ext === '.doc') {\r\n        throw new Error('I file .doc non sono supportati. Converti in .docx o .pdf');\r\n    } else if (mimeType === 'text/plain' || ext === '.txt') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else if (mimeType === 'text/markdown' || ext === '.md') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else {\r\n        throw new Error('Formato file non supportato');\r\n    }\r\n}\r\n\r\n// Funzione per tradurre testo usando OpenAI\r\nasync function translateText(text, targetLanguage, preserveFormatting) {\r\n    try {\r\n        const languageNames = {\r\n            'it': 'Italiano',\r\n            'en': 'Inglese',\r\n            'es': 'Spagnolo',\r\n            'fr': 'Francese',\r\n            'de': 'Tedesco',\r\n            'pt': 'Portoghese',\r\n            'ru': 'Russo',\r\n            'ja': 'Giapponese',\r\n            'zh': 'Cinese',\r\n            'ar': 'Arabo'\r\n        };\r\n        \r\n        const targetLangName = languageNames[targetLanguage] || targetLanguage;\r\n        \r\n        const prompt = preserveFormatting \r\n            ? `Traduci il seguente testo in ${targetLangName} mantenendo ESATTAMENTE la stessa formattazione, struttura, interruzioni di riga e spaziatura. Non aggiungere commenti o spiegazioni, restituisci solo il testo tradotto:\\n\\n${text}`\r\n            : `Traduci il seguente testo in ${targetLangName}. Restituisci solo la traduzione senza commenti:\\n\\n${text}`;\r\n        \r\n        const response = await openai.chat.completions.create({\r\n            model: 'gpt-4o-mini',\r\n            messages: [\r\n                { role: 'system', content: 'Sei un traduttore professionale. Traduci il testo mantenendo il tono e lo stile originale.' },\r\n                { role: 'user', content: prompt }\r\n            ],\r\n            temperature: 0.3,\r\n        });\r\n        \r\n        return response.choices[0].message.content;\r\n    } catch (error) {\r\n        console.error('Errore traduzione con OpenAI:', error);\r\n        throw new Error('Errore durante la traduzione del testo');\r\n    }\r\n}\r\n\r\n// Funzione per creare documento tradotto\r\nasync function createTranslatedDocument(originalText, translatedText, originalPath, originalFilename, targetLanguage) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (ext === '.pdf') {\r\n        // Per PDF, creiamo un nuovo PDF con il testo tradotto\r\n        // In produzione, useresti pdf-lib per mantenere meglio la formattazione\r\n        const doc = new PDFDocument();\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.pdf`);\r\n        const stream = fs.createWriteStream(outputPath);\r\n        doc.pipe(stream);\r\n        doc.fontSize(12);\r\n        \r\n        // Dividi il testo in paragrafi per una migliore formattazione\r\n        const paragraphs = translatedText.split('\\n\\n');\r\n        paragraphs.forEach((para, index) => {\r\n            if (index > 0) doc.moveDown();\r\n            doc.text(para, { align: 'left', continued: false });\r\n        });\r\n        \r\n        doc.end();\r\n        \r\n        await new Promise((resolve, reject) => {\r\n            stream.on('finish', resolve);\r\n            stream.on('error', reject);\r\n        });\r\n        \r\n        return fs.readFileSync(outputPath);\r\n    } else if (ext === '.docx') {\r\n        // Per DOCX, creiamo un nuovo documento\r\n        // In produzione, useresti docx o officegen per mantenere la formattazione\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.txt`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    } else {\r\n        // Per TXT e MD, creiamo un nuovo file di testo\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}${ext}`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    }\r\n}\r\n\r\nexport default async function handler(req, res) {\r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    const uploadDir = path.join(process.cwd(), 'uploads');\r\n    if (!fs.existsSync(uploadDir)) {\r\n        fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    const form = formidable({\r\n        uploadDir,\r\n        keepExtensions: true,\r\n        maxFileSize: 50 * 1024 * 1024, // 50MB\r\n    });\r\n\r\n    try {\r\n        const [fields, files] = await new Promise((resolve, reject) => {\r\n            form.parse(req, (err, fields, files) => {\r\n                if (err) reject(err);\r\n                else resolve([fields, files]);\r\n            });\r\n        });\r\n\r\n        const documentFile = Array.isArray(files.document) ? files.document[0] : files.document;\r\n        const targetLanguage = Array.isArray(fields.targetLanguage) ? fields.targetLanguage[0] : fields.targetLanguage || 'en';\r\n        const preserveFormatting = Array.isArray(fields.preserveFormatting) \r\n            ? fields.preserveFormatting[0] === 'true' \r\n            : fields.preserveFormatting === 'true';\r\n\r\n        if (!documentFile) {\r\n            return res.status(400).json({ error: 'Nessun documento caricato' });\r\n        }\r\n\r\n        // Estrai testo dal documento\r\n        const originalText = await extractText(\r\n            documentFile.filepath,\r\n            documentFile.mimetype,\r\n            documentFile.originalFilename\r\n        );\r\n\r\n        if (!originalText || originalText.trim().length === 0) {\r\n            return res.status(400).json({ error: 'Impossibile estrarre testo dal documento' });\r\n        }\r\n\r\n        // Traduci il testo\r\n        const translatedText = await translateText(originalText, targetLanguage, preserveFormatting);\r\n\r\n        // Crea documento tradotto\r\n        const translatedBuffer = await createTranslatedDocument(\r\n            originalText,\r\n            translatedText,\r\n            documentFile.filepath,\r\n            documentFile.originalFilename,\r\n            targetLanguage\r\n        );\r\n\r\n        // Determina il tipo MIME e nome file\r\n        const ext = path.extname(documentFile.originalFilename).toLowerCase();\r\n        let mimeType = 'application/octet-stream';\r\n        let filename = `translated_${targetLanguage}_${documentFile.originalFilename}`;\r\n\r\n        if (ext === '.pdf') {\r\n            mimeType = 'application/pdf';\r\n        } else if (ext === '.docx') {\r\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n        } else if (ext === '.txt') {\r\n            mimeType = 'text/plain';\r\n        } else if (ext === '.md') {\r\n            mimeType = 'text/markdown';\r\n        }\r\n\r\n        // Cleanup\r\n        try {\r\n            fs.unlinkSync(documentFile.filepath);\r\n            // Pulisci anche i file temporanei creati\r\n            const tempFiles = fs.readdirSync(uploadDir).filter(f => f.startsWith('translated_'));\r\n            tempFiles.forEach(f => {\r\n                try {\r\n                    fs.unlinkSync(path.join(uploadDir, f));\r\n                } catch (e) {}\r\n            });\r\n        } catch (e) {\r\n            console.error('Errore cleanup:', e);\r\n        }\r\n\r\n        res.setHeader('Content-Type', mimeType);\r\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);\r\n        res.status(200).send(translatedBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Traduzione Documenti:', error);\r\n        res.status(500).json({ \r\n            error: error.message || 'Errore durante la traduzione del documento. Riprova con un file diverso.' \r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAEA,MAAM,SAAS,IAAI,uHAAM,CAAC;IACtB,QAAQ,QAAQ,GAAG,CAAC,cAAc;AACtC;AAEO,MAAM,SAAS;IAClB,KAAK;QACD,YAAY;IAChB;AACJ;AAEA,iDAAiD;AACjD,eAAe,YAAY,QAAQ,EAAE,QAAQ,EAAE,gBAAgB;IAC3D,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC,kBAAkB,WAAW;IAEtD,IAAI,aAAa,qBAAqB,QAAQ,QAAQ;QAClD,0EAA0E;QAC1E,IAAI;YACA,6EAA6E;YAC7E,MAAM,EAAE,aAAa,EAAE,GAAG;YAC1B,MAAM,UAAU,cAAc,8BAAY,GAAG;YAC7C,MAAM;YAEN,MAAM,aAAa,wGAAE,CAAC,YAAY,CAAC;YACnC,MAAM,SAAS,MAAM,SAAS;YAC9B,MAAM,OAAO,AAAC,UAAU,OAAO,IAAI,GAAI,OAAO,IAAI,CAAC,IAAI,KAAK;YAE5D,IAAI,CAAC,QAAQ,KAAK,MAAM,KAAK,GAAG;gBAC5B,MAAM,IAAI,MAAM;YACpB;YAEA,OAAO;QACX,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,0BAA0B;YACxC,MAAM,IAAI,MAAM;QACpB;IACJ,OAAO,IAAI,aAAa,6EAA6E,QAAQ,SAAS;QAClH,MAAM,SAAS,MAAM,kHAAO,CAAC,cAAc,CAAC;YAAE,MAAM;QAAS;QAC7D,OAAO,OAAO,KAAK;IACvB,OAAO,IAAI,aAAa,wBAAwB,QAAQ,QAAQ;QAC5D,MAAM,IAAI,MAAM;IACpB,OAAO,IAAI,aAAa,gBAAgB,QAAQ,QAAQ;QACpD,OAAO,wGAAE,CAAC,YAAY,CAAC,UAAU;IACrC,OAAO,IAAI,aAAa,mBAAmB,QAAQ,OAAO;QACtD,OAAO,wGAAE,CAAC,YAAY,CAAC,UAAU;IACrC,OAAO;QACH,MAAM,IAAI,MAAM;IACpB;AACJ;AAEA,4CAA4C;AAC5C,eAAe,cAAc,IAAI,EAAE,cAAc,EAAE,kBAAkB;IACjE,IAAI;QACA,MAAM,gBAAgB;YAClB,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;YACN,MAAM;QACV;QAEA,MAAM,iBAAiB,aAAa,CAAC,eAAe,IAAI;QAExD,MAAM,SAAS,qBACT,CAAC,6BAA6B,EAAE,eAAe,6KAA6K,EAAE,MAAM,GACpO,CAAC,6BAA6B,EAAE,eAAe,oDAAoD,EAAE,MAAM;QAEjH,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YAClD,OAAO;YACP,UAAU;gBACN;oBAAE,MAAM;oBAAU,SAAS;gBAA6F;gBACxH;oBAAE,MAAM;oBAAQ,SAAS;gBAAO;aACnC;YACD,aAAa;QACjB;QAEA,OAAO,SAAS,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO;IAC9C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM,IAAI,MAAM;IACpB;AACJ;AAEA,yCAAyC;AACzC,eAAe,yBAAyB,YAAY,EAAE,cAAc,EAAE,YAAY,EAAE,gBAAgB,EAAE,cAAc;IAChH,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC,kBAAkB,WAAW;IAEtD,IAAI,QAAQ,QAAQ;QAChB,sDAAsD;QACtD,wEAAwE;QACxE,MAAM,MAAM,IAAI,gHAAW;QAC3B,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,4GAAI,CAAC,OAAO,CAAC,eAAe,CAAC,WAAW,EAAE,KAAK,GAAG,GAAG,IAAI,CAAC;QACvF,MAAM,SAAS,wGAAE,CAAC,iBAAiB,CAAC;QACpC,IAAI,IAAI,CAAC;QACT,IAAI,QAAQ,CAAC;QAEb,8DAA8D;QAC9D,MAAM,aAAa,eAAe,KAAK,CAAC;QACxC,WAAW,OAAO,CAAC,CAAC,MAAM;YACtB,IAAI,QAAQ,GAAG,IAAI,QAAQ;YAC3B,IAAI,IAAI,CAAC,MAAM;gBAAE,OAAO;gBAAQ,WAAW;YAAM;QACrD;QAEA,IAAI,GAAG;QAEP,MAAM,IAAI,QAAQ,CAAC,SAAS;YACxB,OAAO,EAAE,CAAC,UAAU;YACpB,OAAO,EAAE,CAAC,SAAS;QACvB;QAEA,OAAO,wGAAE,CAAC,YAAY,CAAC;IAC3B,OAAO,IAAI,QAAQ,SAAS;QACxB,uCAAuC;QACvC,0EAA0E;QAC1E,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,4GAAI,CAAC,OAAO,CAAC,eAAe,CAAC,WAAW,EAAE,KAAK,GAAG,GAAG,IAAI,CAAC;QACvF,wGAAE,CAAC,aAAa,CAAC,YAAY,gBAAgB;QAC7C,OAAO,wGAAE,CAAC,YAAY,CAAC;IAC3B,OAAO;QACH,+CAA+C;QAC/C,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,4GAAI,CAAC,OAAO,CAAC,eAAe,CAAC,WAAW,EAAE,KAAK,GAAG,KAAK,KAAK;QACzF,wGAAE,CAAC,aAAa,CAAC,YAAY,gBAAgB;QAC7C,OAAO,wGAAE,CAAC,YAAY,CAAC;IAC3B;AACJ;AAEe,eAAe,QAAQ,GAAG,EAAE,GAAG;IAC1C,IAAI,IAAI,MAAM,KAAK,QAAQ;QACvB,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAqB;IAC9D;IAEA,MAAM,YAAY,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;IAC3C,IAAI,CAAC,wGAAE,CAAC,UAAU,CAAC,YAAY;QAC3B,wGAAE,CAAC,SAAS,CAAC,WAAW;YAAE,WAAW;QAAK;IAC9C;IAEA,MAAM,OAAO,IAAA,+HAAU,EAAC;QACpB;QACA,gBAAgB;QAChB,aAAa,KAAK,OAAO;IAC7B;IAEA,IAAI;QACA,MAAM,CAAC,QAAQ,MAAM,GAAG,MAAM,IAAI,QAAQ,CAAC,SAAS;YAChD,KAAK,KAAK,CAAC,KAAK,CAAC,KAAK,QAAQ;gBAC1B,IAAI,KAAK,OAAO;qBACX,QAAQ;oBAAC;oBAAQ;iBAAM;YAChC;QACJ;QAEA,MAAM,eAAe,MAAM,OAAO,CAAC,MAAM,QAAQ,IAAI,MAAM,QAAQ,CAAC,EAAE,GAAG,MAAM,QAAQ;QACvF,MAAM,iBAAiB,MAAM,OAAO,CAAC,OAAO,cAAc,IAAI,OAAO,cAAc,CAAC,EAAE,GAAG,OAAO,cAAc,IAAI;QAClH,MAAM,qBAAqB,MAAM,OAAO,CAAC,OAAO,kBAAkB,IAC5D,OAAO,kBAAkB,CAAC,EAAE,KAAK,SACjC,OAAO,kBAAkB,KAAK;QAEpC,IAAI,CAAC,cAAc;YACf,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAA4B;QACrE;QAEA,6BAA6B;QAC7B,MAAM,eAAe,MAAM,YACvB,aAAa,QAAQ,EACrB,aAAa,QAAQ,EACrB,aAAa,gBAAgB;QAGjC,IAAI,CAAC,gBAAgB,aAAa,IAAI,GAAG,MAAM,KAAK,GAAG;YACnD,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBAAE,OAAO;YAA2C;QACpF;QAEA,mBAAmB;QACnB,MAAM,iBAAiB,MAAM,cAAc,cAAc,gBAAgB;QAEzE,0BAA0B;QAC1B,MAAM,mBAAmB,MAAM,yBAC3B,cACA,gBACA,aAAa,QAAQ,EACrB,aAAa,gBAAgB,EAC7B;QAGJ,qCAAqC;QACrC,MAAM,MAAM,4GAAI,CAAC,OAAO,CAAC,aAAa,gBAAgB,EAAE,WAAW;QACnE,IAAI,WAAW;QACf,IAAI,WAAW,CAAC,WAAW,EAAE,eAAe,CAAC,EAAE,aAAa,gBAAgB,EAAE;QAE9E,IAAI,QAAQ,QAAQ;YAChB,WAAW;QACf,OAAO,IAAI,QAAQ,SAAS;YACxB,WAAW;QACf,OAAO,IAAI,QAAQ,QAAQ;YACvB,WAAW;QACf,OAAO,IAAI,QAAQ,OAAO;YACtB,WAAW;QACf;QAEA,UAAU;QACV,IAAI;YACA,wGAAE,CAAC,UAAU,CAAC,aAAa,QAAQ;YACnC,yCAAyC;YACzC,MAAM,YAAY,wGAAE,CAAC,WAAW,CAAC,WAAW,MAAM,CAAC,CAAA,IAAK,EAAE,UAAU,CAAC;YACrE,UAAU,OAAO,CAAC,CAAA;gBACd,IAAI;oBACA,wGAAE,CAAC,UAAU,CAAC,4GAAI,CAAC,IAAI,CAAC,WAAW;gBACvC,EAAE,OAAO,GAAG,CAAC;YACjB;QACJ,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,mBAAmB;QACrC;QAEA,IAAI,SAAS,CAAC,gBAAgB;QAC9B,IAAI,SAAS,CAAC,uBAAuB,CAAC,qBAAqB,EAAE,UAAU;QACvE,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;IAEzB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oCAAoC;QAClD,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YACjB,OAAO,MAAM,OAAO,IAAI;QAC5B;IACJ;AACJ"}}]
}