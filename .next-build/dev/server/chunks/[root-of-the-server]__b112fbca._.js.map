{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jurit/OneDrive/Desktop/sito%20upscale/pages/api/tools/translate-document.js"],"sourcesContent":["import formidable from 'formidable';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport mammoth from 'mammoth';\r\nimport PDFDocument from 'pdfkit';\r\nimport OpenAI from 'openai';\r\nimport Tesseract from 'tesseract.js';\r\nimport sharp from 'sharp';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const config = {\r\n    api: {\r\n        bodyParser: false,\r\n    },\r\n};\r\n\r\n// Funzione per estrarre testo da diversi formati\r\nasync function extractText(filePath, mimeType, originalFilename) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (mimeType === 'application/pdf' || ext === '.pdf') {\r\n        // Estrazione testo da PDF usando pdf-parse con fallback OCR\r\n        let text = '';\r\n        let numPages = 1;\r\n        \r\n        // Tentativo 1: pdf-parse per PDF con testo nativo\r\n        try {\r\n            console.log('[PDF Extract] Inizio estrazione PDF:', originalFilename);\r\n            \r\n            // Prova diversi modi di importare pdf-parse per compatibilità Turbopack\r\n            let pdfParse;\r\n            try {\r\n                const mod = await import('pdf-parse');\r\n                pdfParse = mod.default || mod;\r\n            } catch (e) {\r\n                console.log('[PDF Extract] Import ESM fallito, provo require dinamico');\r\n                // Fallback per ambienti che non supportano ESM import di CommonJS\r\n                pdfParse = require('pdf-parse');\r\n            }\r\n            \r\n            if (typeof pdfParse !== 'function') {\r\n                throw new Error('pdf-parse non disponibile come funzione');\r\n            }\r\n            \r\n            console.log('[PDF Extract] pdf-parse caricato correttamente');\r\n            \r\n            const dataBuffer = fs.readFileSync(filePath);\r\n            console.log('[PDF Extract] Buffer letto, dimensione:', dataBuffer.length, 'bytes');\r\n            \r\n            const result = await pdfParse(dataBuffer);\r\n            console.log('[PDF Extract] Parsing completato, testo estratto:', result?.text?.length || 0, 'caratteri');\r\n            console.log('[PDF Extract] Numero pagine:', result?.numpages || 1);\r\n            \r\n            text = (result && result.text) ? result.text.trim() : '';\r\n            numPages = result?.numpages || 1;\r\n        } catch (pdfError) {\r\n            console.log('[PDF Extract] pdf-parse fallito:', pdfError.message);\r\n            text = ''; // Continua con OCR\r\n        }\r\n\r\n        // Tentativo 2: OCR se pdf-parse ha fallito o testo insufficiente\r\n        if (!text || text.length < 50) {\r\n            console.log('[PDF Extract] Testo insufficiente, uso OCR automatico...');\r\n            try {\r\n                const dataBuffer = fs.readFileSync(filePath);\r\n                const allTexts = [];\r\n                \r\n                // Converti ogni pagina del PDF in immagine e fai OCR\r\n                console.log('[PDF Extract] Conversione PDF in immagini per OCR...');\r\n                \r\n                // Prova a ottenere il numero di pagine\r\n                let totalPages = numPages;\r\n                let processAllPages = false;\r\n                \r\n                // Se abbiamo il numero di pagine da pdf-parse, usalo\r\n                if (numPages > 1) {\r\n                    totalPages = numPages;\r\n                    console.log('[PDF Extract] Numero pagine da pdf-parse:', totalPages);\r\n                } else {\r\n                    // Altrimenti prova a ottenere il numero di pagine processando fino a quando non fallisce\r\n                    // o usando un limite ragionevole\r\n                    totalPages = 10; // Limite di default\r\n                    processAllPages = true;\r\n                    console.log('[PDF Extract] Numero pagine sconosciuto, processo fino a', totalPages, 'pagine');\r\n                }\r\n                \r\n                // Processa ogni pagina (limite a 10 pagine per performance)\r\n                const maxPages = Math.min(totalPages, 10);\r\n                console.log(`[PDF Extract] Processo ${maxPages} pagina/e con OCR...`);\r\n                \r\n                for (let page = 0; page < maxPages; page++) {\r\n                    try {\r\n                        console.log(`[PDF Extract] Processo pagina ${page + 1}/${maxPages}...`);\r\n                        \r\n                        // Converti la pagina PDF in immagine PNG usando sharp\r\n                        const imageBuffer = await sharp(dataBuffer, {\r\n                            density: 300, // DPI alto per migliore qualità OCR\r\n                            page: page\r\n                        })\r\n                        .png()\r\n                        .toBuffer();\r\n                        \r\n                        console.log(`[PDF Extract] Pagina ${page + 1} convertita in immagine, dimensione:`, imageBuffer.length, 'bytes');\r\n                        \r\n                        // Preprocessa l'immagine per migliorare OCR\r\n                        const processedImage = await sharp(imageBuffer)\r\n                            .greyscale()\r\n                            .normalize()\r\n                            .sharpen()\r\n                            .toBuffer();\r\n                        \r\n                        // Esegui OCR sull'immagine\r\n                        const { data: { text: pageText } } = await Tesseract.recognize(\r\n                            processedImage,\r\n                            'ita+eng',\r\n                            {\r\n                                logger: m => {\r\n                                    if (m.status === 'recognizing text') {\r\n                                        console.log(`[OCR] Pagina ${page + 1} - Progress: ${Math.round(m.progress * 100)}%`);\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        if (pageText && pageText.trim().length > 0) {\r\n                            allTexts.push(pageText.trim());\r\n                            console.log(`[OCR] Pagina ${page + 1} - Testo estratto:`, pageText.trim().length, 'caratteri');\r\n                        }\r\n                    } catch (pageError) {\r\n                        console.error(`[OCR] Errore processando pagina ${page + 1}:`, pageError.message);\r\n                        // Se stiamo processando tutte le pagine e questa fallisce, potrebbe essere la fine del PDF\r\n                        if (processAllPages && pageError.message.includes('page')) {\r\n                            console.log(`[PDF Extract] Raggiunta fine del PDF alla pagina ${page + 1}`);\r\n                            break; // Ferma il loop se non ci sono più pagine\r\n                        }\r\n                        // Altrimenti continua con la pagina successiva\r\n                    }\r\n                }\r\n                \r\n                if (allTexts.length > 0) {\r\n                    const ocrText = allTexts.join('\\n\\n');\r\n                    console.log('[OCR] Testo totale estratto via OCR:', ocrText.length, 'caratteri da', allTexts.length, 'pagina/e');\r\n                    return ocrText;\r\n                } else {\r\n                    throw new Error('Nessun testo estratto dalle immagini del PDF');\r\n                }\r\n            } catch (ocrError) {\r\n                console.error('[OCR] Errore OCR:', ocrError.message);\r\n                throw new Error(`Errore durante l'estrazione del testo: ${ocrError.message}`);\r\n            }\r\n        }\r\n\r\n        console.log('[PDF Extract] Estrazione completata con successo');\r\n        return text;\r\n    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || ext === '.docx') {\r\n        const result = await mammoth.extractRawText({ path: filePath });\r\n        return result.value;\r\n    } else if (mimeType === 'application/msword' || ext === '.doc') {\r\n        throw new Error('I file .doc non sono supportati. Converti in .docx o .pdf');\r\n    } else if (mimeType === 'text/plain' || ext === '.txt') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else if (mimeType === 'text/markdown' || ext === '.md') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else {\r\n        throw new Error('Formato file non supportato');\r\n    }\r\n}\r\n\r\n// Funzione per tradurre testo usando OpenAI\r\nasync function translateText(text, targetLanguage, preserveFormatting) {\r\n    try {\r\n        const languageNames = {\r\n            'it': 'Italiano',\r\n            'en': 'Inglese',\r\n            'es': 'Spagnolo',\r\n            'fr': 'Francese',\r\n            'de': 'Tedesco',\r\n            'pt': 'Portoghese',\r\n            'ru': 'Russo',\r\n            'ja': 'Giapponese',\r\n            'zh': 'Cinese',\r\n            'ar': 'Arabo'\r\n        };\r\n        \r\n        const targetLangName = languageNames[targetLanguage] || targetLanguage;\r\n        \r\n        const prompt = preserveFormatting \r\n            ? `Traduci il seguente testo in ${targetLangName} mantenendo ESATTAMENTE la stessa formattazione, struttura, interruzioni di riga e spaziatura. Non aggiungere commenti o spiegazioni, restituisci solo il testo tradotto:\\n\\n${text}`\r\n            : `Traduci il seguente testo in ${targetLangName}. Restituisci solo la traduzione senza commenti:\\n\\n${text}`;\r\n        \r\n        const response = await openai.chat.completions.create({\r\n            model: 'gpt-4o-mini',\r\n            messages: [\r\n                { role: 'system', content: 'Sei un traduttore professionale. Traduci il testo mantenendo il tono e lo stile originale.' },\r\n                { role: 'user', content: prompt }\r\n            ],\r\n            temperature: 0.3,\r\n        });\r\n        \r\n        return response.choices[0].message.content;\r\n    } catch (error) {\r\n        console.error('Errore traduzione con OpenAI:', error);\r\n        throw new Error('Errore durante la traduzione del testo');\r\n    }\r\n}\r\n\r\n// Funzione per creare documento tradotto\r\nasync function createTranslatedDocument(originalText, translatedText, originalPath, originalFilename, targetLanguage) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (ext === '.pdf') {\r\n        // Per PDF, creiamo un nuovo PDF con il testo tradotto\r\n        // In produzione, useresti pdf-lib per mantenere meglio la formattazione\r\n        const doc = new PDFDocument();\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.pdf`);\r\n        const stream = fs.createWriteStream(outputPath);\r\n        doc.pipe(stream);\r\n        doc.fontSize(12);\r\n        \r\n        // Dividi il testo in paragrafi per una migliore formattazione\r\n        const paragraphs = translatedText.split('\\n\\n');\r\n        paragraphs.forEach((para, index) => {\r\n            if (index > 0) doc.moveDown();\r\n            doc.text(para, { align: 'left', continued: false });\r\n        });\r\n        \r\n        doc.end();\r\n        \r\n        await new Promise((resolve, reject) => {\r\n            stream.on('finish', resolve);\r\n            stream.on('error', reject);\r\n        });\r\n        \r\n        return fs.readFileSync(outputPath);\r\n    } else if (ext === '.docx') {\r\n        // Per DOCX, creiamo un nuovo documento\r\n        // In produzione, useresti docx o officegen per mantenere la formattazione\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.txt`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    } else {\r\n        // Per TXT e MD, creiamo un nuovo file di testo\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}${ext}`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    }\r\n}\r\n\r\nexport default async function handler(req, res) {\r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    const uploadDir = path.join(process.cwd(), 'uploads');\r\n    if (!fs.existsSync(uploadDir)) {\r\n        fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    const form = formidable({\r\n        uploadDir,\r\n        keepExtensions: true,\r\n        maxFileSize: 50 * 1024 * 1024, // 50MB\r\n    });\r\n\r\n    try {\r\n        const [fields, files] = await new Promise((resolve, reject) => {\r\n            form.parse(req, (err, fields, files) => {\r\n                if (err) reject(err);\r\n                else resolve([fields, files]);\r\n            });\r\n        });\r\n\r\n        const documentFile = Array.isArray(files.document) ? files.document[0] : files.document;\r\n        const targetLanguage = Array.isArray(fields.targetLanguage) ? fields.targetLanguage[0] : fields.targetLanguage || 'en';\r\n        const preserveFormatting = Array.isArray(fields.preserveFormatting) \r\n            ? fields.preserveFormatting[0] === 'true' \r\n            : fields.preserveFormatting === 'true';\r\n\r\n        if (!documentFile) {\r\n            return res.status(400).json({ error: 'Nessun documento caricato' });\r\n        }\r\n\r\n        // Estrai testo dal documento\r\n        const originalText = await extractText(\r\n            documentFile.filepath,\r\n            documentFile.mimetype,\r\n            documentFile.originalFilename\r\n        );\r\n\r\n        if (!originalText || originalText.trim().length === 0) {\r\n            return res.status(400).json({ error: 'Impossibile estrarre testo dal documento' });\r\n        }\r\n\r\n        // Traduci il testo\r\n        const translatedText = await translateText(originalText, targetLanguage, preserveFormatting);\r\n\r\n        // Crea documento tradotto\r\n        const translatedBuffer = await createTranslatedDocument(\r\n            originalText,\r\n            translatedText,\r\n            documentFile.filepath,\r\n            documentFile.originalFilename,\r\n            targetLanguage\r\n        );\r\n\r\n        // Determina il tipo MIME e nome file\r\n        const ext = path.extname(documentFile.originalFilename).toLowerCase();\r\n        let mimeType = 'application/octet-stream';\r\n        let filename = `translated_${targetLanguage}_${documentFile.originalFilename}`;\r\n\r\n        if (ext === '.pdf') {\r\n            mimeType = 'application/pdf';\r\n        } else if (ext === '.docx') {\r\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n        } else if (ext === '.txt') {\r\n            mimeType = 'text/plain';\r\n        } else if (ext === '.md') {\r\n            mimeType = 'text/markdown';\r\n        }\r\n\r\n        // Cleanup\r\n        try {\r\n            fs.unlinkSync(documentFile.filepath);\r\n            // Pulisci anche i file temporanei creati\r\n            const tempFiles = fs.readdirSync(uploadDir).filter(f => f.startsWith('translated_'));\r\n            tempFiles.forEach(f => {\r\n                try {\r\n                    fs.unlinkSync(path.join(uploadDir, f));\r\n                } catch (e) {}\r\n            });\r\n        } catch (e) {\r\n            console.error('Errore cleanup:', e);\r\n        }\r\n\r\n        res.setHeader('Content-Type', mimeType);\r\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);\r\n        res.status(200).send(translatedBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Traduzione Documenti:', error);\r\n        res.status(500).json({ \r\n            error: error.message || 'Errore durante la traduzione del documento. Riprova con un file diverso.' \r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}