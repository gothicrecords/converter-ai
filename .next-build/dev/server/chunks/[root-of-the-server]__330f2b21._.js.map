{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jurit/OneDrive/Desktop/sito%20upscale/pages/api/tools/translate-document.js"],"sourcesContent":["import formidable from 'formidable';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport mammoth from 'mammoth';\r\nimport PDFDocument from 'pdfkit';\r\nimport OpenAI from 'openai';\r\nimport Tesseract from 'tesseract.js';\r\nimport sharp from 'sharp';\r\nimport pdfParse from 'pdf-parse';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const config = {\r\n    api: {\r\n        bodyParser: false,\r\n    },\r\n};\r\n\r\n// Funzione per estrarre testo da diversi formati\r\nasync function extractText(filePath, mimeType, originalFilename) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (mimeType === 'application/pdf' || ext === '.pdf') {\r\n        // Estrazione testo da PDF usando pdf-parse con fallback OCR\r\n        let text = '';\r\n        let numPages = 1;\r\n        \r\n        // Tentativo 1: pdf-parse per PDF con testo nativo\r\n        try {\r\n            console.log('[PDF Extract] Inizio estrazione PDF:', originalFilename);\r\n            \r\n            const dataBuffer = fs.readFileSync(filePath);\r\n            console.log('[PDF Extract] Buffer letto, dimensione:', dataBuffer.length, 'bytes');\r\n            \r\n            const result = await pdfParse(dataBuffer);\r\n            console.log('[PDF Extract] Parsing completato, testo estratto:', result?.text?.length || 0, 'caratteri');\r\n            console.log('[PDF Extract] Numero pagine:', result?.numpages || 1);\r\n            \r\n            text = (result && result.text) ? result.text.trim() : '';\r\n            numPages = result?.numpages || 1;\r\n        } catch (pdfError) {\r\n            console.log('[PDF Extract] pdf-parse fallito:', pdfError.message);\r\n            console.error('[PDF Extract] Stack:', pdfError.stack);\r\n            text = ''; // Continua con OCR\r\n        }\r\n\r\n        // Tentativo 2: OCR se pdf-parse ha fallito o testo insufficiente\r\n        // Riduciamo la soglia minima a 10 caratteri per essere meno restrittivi\r\n        if (!text || text.trim().length < 10) {\r\n            console.log('[PDF Extract] Testo insufficiente, uso OCR automatico...');\r\n            try {\r\n                const dataBuffer = fs.readFileSync(filePath);\r\n                const allTexts = [];\r\n                \r\n                // Converti ogni pagina del PDF in immagine e fai OCR\r\n                console.log('[PDF Extract] Conversione PDF in immagini per OCR...');\r\n                \r\n                // Sharp potrebbe non supportare PDF direttamente senza librerie native\r\n                // Proviamo diversi approcci per convertire PDF in immagine\r\n                console.log('[PDF Extract] Conversione prima pagina PDF in immagine per OCR...');\r\n                \r\n                let imageBuffer = null;\r\n                \r\n                // Tentativo 1: Sharp con pages: 1 (plurale)\r\n                try {\r\n                    console.log('[PDF Extract] Tentativo 1: Sharp con pages: 1');\r\n                    imageBuffer = await sharp(dataBuffer, {\r\n                        density: 300,\r\n                        pages: 1\r\n                    })\r\n                    .png()\r\n                    .toBuffer();\r\n                    console.log('[PDF Extract] Successo con pages: 1');\r\n                } catch (sharpError1) {\r\n                    console.log('[PDF Extract] Fallito con pages: 1, errore:', sharpError1.message);\r\n                    \r\n                    // Tentativo 2: Sharp con page: 0 (singolare, 0-based)\r\n                    try {\r\n                        console.log('[PDF Extract] Tentativo 2: Sharp con page: 0');\r\n                        imageBuffer = await sharp(dataBuffer, {\r\n                            density: 300,\r\n                            page: 0\r\n                        })\r\n                        .png()\r\n                        .toBuffer();\r\n                        console.log('[PDF Extract] Successo con page: 0');\r\n                    } catch (sharpError2) {\r\n                        console.log('[PDF Extract] Fallito con page: 0, errore:', sharpError2.message);\r\n                        \r\n                        // Tentativo 3: Sharp senza specificare pagina (prima pagina di default)\r\n                        try {\r\n                            console.log('[PDF Extract] Tentativo 3: Sharp senza specificare pagina');\r\n                            imageBuffer = await sharp(dataBuffer, {\r\n                                density: 300\r\n                            })\r\n                            .png()\r\n                            .toBuffer();\r\n                            console.log('[PDF Extract] Successo senza specificare pagina');\r\n                        } catch (sharpError3) {\r\n                            console.error('[PDF Extract] Tutti i tentativi Sharp falliti');\r\n                            console.error('[PDF Extract] Errore finale:', sharpError3.message);\r\n                            \r\n                            // Se Sharp non può processare il PDF, usiamo OpenAI come fallback (stesso metodo dei documenti AI)\r\n                            console.log('[PDF Extract] Sharp fallito, uso OpenAI per estrazione testo (stesso metodo documenti AI)');\r\n                            try {\r\n                                const { extractTextFromPdfWithOpenAI } = await import('../../../lib/openai.js');\r\n                                \r\n                                // Salva temporaneamente il file per l'upload\r\n                                const os = await import('os');\r\n                                const tempDir = os.tmpdir();\r\n                                const tempFilePath = path.join(tempDir, `temp_${Date.now()}_${originalFilename}`);\r\n                                \r\n                                try {\r\n                                    // Scrivi il buffer su file temporaneo\r\n                                    fs.writeFileSync(tempFilePath, dataBuffer);\r\n                                    \r\n                                    // Estrai testo con OpenAI (stesso metodo dei documenti AI)\r\n                                    const openaiText = await extractTextFromPdfWithOpenAI(tempFilePath);\r\n                                    \r\n                                    if (openaiText && openaiText.trim().length > 0) {\r\n                                        console.log('[OpenAI] Testo estratto dal PDF:', openaiText.trim().length, 'caratteri');\r\n                                        return openaiText.trim();\r\n                                    } else {\r\n                                        throw new Error('OpenAI non ha estratto testo dal PDF');\r\n                                    }\r\n                                } finally {\r\n                                    // Pulisci file temporaneo\r\n                                    try {\r\n                                        if (fs.existsSync(tempFilePath)) {\r\n                                            fs.unlinkSync(tempFilePath);\r\n                                        }\r\n                                    } catch (cleanupError) {\r\n                                        console.warn('Errore pulizia file temporaneo:', cleanupError);\r\n                                    }\r\n                                }\r\n                            } catch (openaiError) {\r\n                                console.error('[OpenAI] Estrazione testo fallita:', openaiError.message);\r\n                                \r\n                                // Verifica se è un errore di rate limit\r\n                                const isRateLimit = openaiError.message && (\r\n                                    openaiError.message.includes('rate') || \r\n                                    openaiError.message.includes('Limite') ||\r\n                                    openaiError.message.includes('429')\r\n                                );\r\n                                \r\n                                if (isRateLimit) {\r\n                                    console.log('[OpenAI] Rate limit raggiunto, provo OCR diretto come alternativa');\r\n                                }\r\n                                \r\n                                // Ultimo tentativo: OCR diretto sul PDF con Tesseract\r\n                                console.log('[PDF Extract] Tentativo finale: OCR diretto sul PDF');\r\n                                try {\r\n                                    const { data: { text: directOcrText } } = await Tesseract.recognize(\r\n                                        dataBuffer,\r\n                                        'ita+eng',\r\n                                        {\r\n                                            logger: m => {\r\n                                                if (m.status === 'recognizing text') {\r\n                                                    console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                    \r\n                                    if (directOcrText && directOcrText.trim().length > 0) {\r\n                                        console.log('[OCR] Testo estratto direttamente dal PDF:', directOcrText.trim().length, 'caratteri');\r\n                                        return directOcrText.trim();\r\n                                    } else {\r\n                                        throw new Error('OCR diretto non ha estratto testo');\r\n                                    }\r\n                                } catch (directOcrError) {\r\n                                    console.error('[OCR] OCR diretto fallito:', directOcrError.message);\r\n                                    \r\n                                    // Costruisci messaggio di errore più informativo e utile\r\n                                    let errorMessage = '';\r\n                                    let suggestions = [];\r\n                                    \r\n                                    if (isRateLimit) {\r\n                                        errorMessage = 'OpenAI ha raggiunto il limite di richieste. ';\r\n                                        suggestions = [\r\n                                            'Attendi 1-2 minuti e riprova',\r\n                                            'Prova con un PDF che contiene testo nativo (non solo immagini scansionate)',\r\n                                            'Converti il PDF in DOCX o TXT usando un altro tool prima di tradurlo',\r\n                                            'Prova a estrarre il testo manualmente e incollalo come file TXT'\r\n                                        ];\r\n                                    } else {\r\n                                        errorMessage = 'Impossibile estrarre testo dal PDF. ';\r\n                                        suggestions = [\r\n                                            'Il PDF potrebbe essere protetto o corrotto',\r\n                                            'Il PDF potrebbe contenere solo immagini senza testo estraibile',\r\n                                            'Prova a convertire il PDF in DOCX o TXT usando un altro tool',\r\n                                            'Prova con un PDF diverso che contiene testo nativo'\r\n                                        ];\r\n                                    }\r\n                                    \r\n                                    errorMessage += '\\n\\nCosa puoi fare:\\n';\r\n                                    suggestions.forEach((suggestion, index) => {\r\n                                        errorMessage += `${index + 1}. ${suggestion}\\n`;\r\n                                    });\r\n                                    \r\n                                    errorMessage += '\\nMetodi tentati: pdf-parse, conversione Sharp, estrazione OpenAI, OCR diretto.';\r\n                                    \r\n                                    throw new Error(errorMessage);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Se abbiamo un'immagine, processiamola\r\n                if (imageBuffer) {\r\n                    console.log('[PDF Extract] Immagine ottenuta, dimensione:', imageBuffer.length, 'bytes');\r\n                    \r\n                    try {\r\n                        // Preprocessa l'immagine per migliorare OCR\r\n                        const processedImage = await sharp(imageBuffer)\r\n                            .greyscale()\r\n                            .normalize()\r\n                            .sharpen()\r\n                            .toBuffer();\r\n                        \r\n                        // Esegui OCR sull'immagine\r\n                        console.log('[OCR] Esecuzione OCR sulla prima pagina...');\r\n                        const { data: { text: pageText } } = await Tesseract.recognize(\r\n                            processedImage,\r\n                            'ita+eng',\r\n                            {\r\n                                logger: m => {\r\n                                    if (m.status === 'recognizing text') {\r\n                                        console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        if (pageText && pageText.trim().length > 0) {\r\n                            allTexts.push(pageText.trim());\r\n                            console.log('[OCR] Testo estratto dalla prima pagina:', pageText.trim().length, 'caratteri');\r\n                        } else {\r\n                            throw new Error('OCR non ha estratto testo dall\\'immagine');\r\n                        }\r\n                    } catch (processError) {\r\n                        console.error('[OCR] Errore processando immagine:', processError.message);\r\n                        throw new Error(`Errore durante l'OCR: ${processError.message}`);\r\n                    }\r\n                } else {\r\n                    throw new Error('Impossibile ottenere immagine dal PDF');\r\n                }\r\n                \r\n                if (allTexts.length > 0) {\r\n                    const ocrText = allTexts.join('\\n\\n');\r\n                    console.log('[OCR] Testo totale estratto via OCR:', ocrText.length, 'caratteri da', allTexts.length, 'pagina/e');\r\n                    return ocrText;\r\n                } else {\r\n                    throw new Error('Nessun testo estratto dalle immagini del PDF');\r\n                }\r\n            } catch (ocrError) {\r\n                console.error('[OCR] Errore OCR:', ocrError.message);\r\n                throw new Error(`Errore durante l'estrazione del testo: ${ocrError.message}`);\r\n            }\r\n        }\r\n\r\n        console.log('[PDF Extract] Estrazione completata con successo');\r\n        return text;\r\n    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || ext === '.docx') {\r\n        const result = await mammoth.extractRawText({ path: filePath });\r\n        return result.value;\r\n    } else if (mimeType === 'application/msword' || ext === '.doc') {\r\n        throw new Error('I file .doc non sono supportati. Converti in .docx o .pdf');\r\n    } else if (mimeType === 'text/plain' || ext === '.txt') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else if (mimeType === 'text/markdown' || ext === '.md') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else {\r\n        throw new Error('Formato file non supportato');\r\n    }\r\n}\r\n\r\n// Funzione per tradurre testo usando OpenAI\r\nasync function translateText(text, targetLanguage, preserveFormatting) {\r\n    try {\r\n        const languageNames = {\r\n            'it': 'Italiano',\r\n            'en': 'Inglese',\r\n            'es': 'Spagnolo',\r\n            'fr': 'Francese',\r\n            'de': 'Tedesco',\r\n            'pt': 'Portoghese',\r\n            'ru': 'Russo',\r\n            'ja': 'Giapponese',\r\n            'zh': 'Cinese',\r\n            'ar': 'Arabo'\r\n        };\r\n        \r\n        const targetLangName = languageNames[targetLanguage] || targetLanguage;\r\n        \r\n        const prompt = preserveFormatting \r\n            ? `Traduci il seguente testo in ${targetLangName} mantenendo ESATTAMENTE la stessa formattazione, struttura, interruzioni di riga e spaziatura. Non aggiungere commenti o spiegazioni, restituisci solo il testo tradotto:\\n\\n${text}`\r\n            : `Traduci il seguente testo in ${targetLangName}. Restituisci solo la traduzione senza commenti:\\n\\n${text}`;\r\n        \r\n        const response = await openai.chat.completions.create({\r\n            model: 'gpt-4o-mini',\r\n            messages: [\r\n                { role: 'system', content: 'Sei un traduttore professionale. Traduci il testo mantenendo il tono e lo stile originale.' },\r\n                { role: 'user', content: prompt }\r\n            ],\r\n            temperature: 0.3,\r\n        });\r\n        \r\n        return response.choices[0].message.content;\r\n    } catch (error) {\r\n        console.error('Errore traduzione con OpenAI:', error);\r\n        throw new Error('Errore durante la traduzione del testo');\r\n    }\r\n}\r\n\r\n// Funzione per creare documento tradotto\r\nasync function createTranslatedDocument(originalText, translatedText, originalPath, originalFilename, targetLanguage) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (ext === '.pdf') {\r\n        // Per PDF, creiamo un nuovo PDF con il testo tradotto\r\n        // In produzione, useresti pdf-lib per mantenere meglio la formattazione\r\n        const doc = new PDFDocument();\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.pdf`);\r\n        const stream = fs.createWriteStream(outputPath);\r\n        doc.pipe(stream);\r\n        doc.fontSize(12);\r\n        \r\n        // Dividi il testo in paragrafi per una migliore formattazione\r\n        const paragraphs = translatedText.split('\\n\\n');\r\n        paragraphs.forEach((para, index) => {\r\n            if (index > 0) doc.moveDown();\r\n            doc.text(para, { align: 'left', continued: false });\r\n        });\r\n        \r\n        doc.end();\r\n        \r\n        await new Promise((resolve, reject) => {\r\n            stream.on('finish', resolve);\r\n            stream.on('error', reject);\r\n        });\r\n        \r\n        return fs.readFileSync(outputPath);\r\n    } else if (ext === '.docx') {\r\n        // Per DOCX, creiamo un nuovo documento\r\n        // In produzione, useresti docx o officegen per mantenere la formattazione\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.txt`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    } else {\r\n        // Per TXT e MD, creiamo un nuovo file di testo\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}${ext}`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    }\r\n}\r\n\r\nexport default async function handler(req, res) {\r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    const uploadDir = path.join(process.cwd(), 'uploads');\r\n    if (!fs.existsSync(uploadDir)) {\r\n        fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    const form = formidable({\r\n        uploadDir,\r\n        keepExtensions: true,\r\n        maxFileSize: 50 * 1024 * 1024, // 50MB\r\n    });\r\n\r\n    try {\r\n        const [fields, files] = await new Promise((resolve, reject) => {\r\n            form.parse(req, (err, fields, files) => {\r\n                if (err) reject(err);\r\n                else resolve([fields, files]);\r\n            });\r\n        });\r\n\r\n        const documentFile = Array.isArray(files.document) ? files.document[0] : files.document;\r\n        const targetLanguage = Array.isArray(fields.targetLanguage) ? fields.targetLanguage[0] : fields.targetLanguage || 'en';\r\n        const preserveFormatting = Array.isArray(fields.preserveFormatting) \r\n            ? fields.preserveFormatting[0] === 'true' \r\n            : fields.preserveFormatting === 'true';\r\n\r\n        if (!documentFile) {\r\n            return res.status(400).json({ error: 'Nessun documento caricato' });\r\n        }\r\n\r\n        // Estrai testo dal documento\r\n        const originalText = await extractText(\r\n            documentFile.filepath,\r\n            documentFile.mimetype,\r\n            documentFile.originalFilename\r\n        );\r\n\r\n        if (!originalText || originalText.trim().length === 0) {\r\n            return res.status(400).json({ error: 'Impossibile estrarre testo dal documento' });\r\n        }\r\n\r\n        // Traduci il testo\r\n        const translatedText = await translateText(originalText, targetLanguage, preserveFormatting);\r\n\r\n        // Crea documento tradotto\r\n        const translatedBuffer = await createTranslatedDocument(\r\n            originalText,\r\n            translatedText,\r\n            documentFile.filepath,\r\n            documentFile.originalFilename,\r\n            targetLanguage\r\n        );\r\n\r\n        // Determina il tipo MIME e nome file\r\n        const ext = path.extname(documentFile.originalFilename).toLowerCase();\r\n        let mimeType = 'application/octet-stream';\r\n        let filename = `translated_${targetLanguage}_${documentFile.originalFilename}`;\r\n\r\n        if (ext === '.pdf') {\r\n            mimeType = 'application/pdf';\r\n        } else if (ext === '.docx') {\r\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n        } else if (ext === '.txt') {\r\n            mimeType = 'text/plain';\r\n        } else if (ext === '.md') {\r\n            mimeType = 'text/markdown';\r\n        }\r\n\r\n        // Cleanup\r\n        try {\r\n            fs.unlinkSync(documentFile.filepath);\r\n            // Pulisci anche i file temporanei creati\r\n            const tempFiles = fs.readdirSync(uploadDir).filter(f => f.startsWith('translated_'));\r\n            tempFiles.forEach(f => {\r\n                try {\r\n                    fs.unlinkSync(path.join(uploadDir, f));\r\n                } catch (e) {}\r\n            });\r\n        } catch (e) {\r\n            console.error('Errore cleanup:', e);\r\n        }\r\n\r\n        res.setHeader('Content-Type', mimeType);\r\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);\r\n        res.status(200).send(translatedBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Traduzione Documenti:', error);\r\n        console.error('Stack trace:', error.stack);\r\n        console.error('Error details:', {\r\n            message: error.message,\r\n            name: error.name,\r\n            code: error.code\r\n        });\r\n        \r\n        // Determina il messaggio di errore appropriato\r\n        let errorMessage = 'Errore durante la traduzione del documento. Riprova con un file diverso.';\r\n        \r\n        if (error.message) {\r\n            errorMessage = error.message;\r\n        } else if (error.code === 'ENOENT') {\r\n            errorMessage = 'File non trovato. Assicurati di aver caricato un file valido.';\r\n        } else if (error.code === 'LIMIT_FILE_SIZE') {\r\n            errorMessage = 'File troppo grande. Dimensione massima: 50MB.';\r\n        }\r\n        \r\n        res.status(500).json({ \r\n            error: errorMessage,\r\n            details: process.env.NODE_ENV === 'development' ? error.stack : undefined\r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}