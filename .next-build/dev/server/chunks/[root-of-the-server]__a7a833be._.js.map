{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jurit/OneDrive/Desktop/sito%20upscale/lib/openai-queue.js"],"sourcesContent":["// Sistema di queue con retry automatico e rate limiting per OpenAI\r\nimport Bottleneck from 'bottleneck';\r\n\r\n// Configurazione rate limiter per OpenAI\r\n// OpenAI ha limiti: \r\n// - GPT-4o: 10 RPM (requests per minute) per tier gratuito\r\n// - GPT-4o-mini: 500 RPM per tier gratuito\r\n// Usiamo valori conservativi per evitare rate limits\r\nconst limiter = new Bottleneck({\r\n    reservoir: 50, // Numero di richieste disponibili\r\n    reservoirRefreshAmount: 50, // Ricarica ogni intervallo\r\n    reservoirRefreshInterval: 60 * 1000, // 1 minuto\r\n    maxConcurrent: 3, // Massimo 3 richieste concorrenti\r\n    minTime: 200, // Minimo 200ms tra le richieste\r\n});\r\n\r\n// Queue per le richieste con retry automatico\r\nclass OpenAIQueue {\r\n    constructor() {\r\n        this.queue = [];\r\n        this.processing = false;\r\n        this.maxRetries = 3;\r\n        this.baseDelay = 1000; // 1 secondo base delay\r\n    }\r\n\r\n    /**\r\n     * Aggiunge una richiesta alla coda con retry automatico\r\n     * @param {Function} operation - Funzione async da eseguire\r\n     * @param {Object} options - Opzioni per la richiesta\r\n     * @returns {Promise} Promise che si risolve con il risultato\r\n     */\r\n    async add(operation, options = {}) {\r\n        const {\r\n            priority = 5, // Priorità (1-10, più alto = più prioritario)\r\n            maxRetries = this.maxRetries,\r\n            retryDelay = this.baseDelay,\r\n            id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        } = options;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const queueItem = {\r\n                id,\r\n                operation,\r\n                priority,\r\n                maxRetries,\r\n                retryDelay,\r\n                attempts: 0,\r\n                resolve,\r\n                reject,\r\n                timestamp: Date.now(),\r\n            };\r\n\r\n            this.queue.push(queueItem);\r\n            this.queue.sort((a, b) => b.priority - a.priority); // Ordina per priorità\r\n\r\n            // Avvia il processing se non è già in corso\r\n            if (!this.processing) {\r\n                this.processQueue();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Processa la coda delle richieste\r\n     */\r\n    async processQueue() {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const item = this.queue.shift();\r\n\r\n            try {\r\n                // Esegui l'operazione con rate limiting\r\n                const result = await limiter.schedule(async () => {\r\n                    return await this.executeWithRetry(item);\r\n                });\r\n\r\n                item.resolve(result);\r\n            } catch (error) {\r\n                // Se tutti i retry sono falliti, rifiuta la promise\r\n                item.reject(error);\r\n            }\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    /**\r\n     * Esegue un'operazione con retry automatico e backoff esponenziale\r\n     * @param {Object} item - Item della coda\r\n     * @returns {Promise} Risultato dell'operazione\r\n     */\r\n    async executeWithRetry(item) {\r\n        let lastError;\r\n\r\n        for (let attempt = 1; attempt <= item.maxRetries; attempt++) {\r\n            try {\r\n                item.attempts = attempt;\r\n                console.log(`[OpenAI Queue] Tentativo ${attempt}/${item.maxRetries} per richiesta ${item.id}`);\r\n\r\n                const result = await item.operation();\r\n                console.log(`[OpenAI Queue] Richiesta ${item.id} completata con successo`);\r\n                return result;\r\n            } catch (error) {\r\n                lastError = error;\r\n\r\n                // Verifica se è un errore di rate limit\r\n                const isRateLimit = this.isRateLimitError(error);\r\n\r\n                if (isRateLimit) {\r\n                    // Per rate limit, usa un delay più lungo\r\n                    const retryAfter = this.extractRetryAfter(error);\r\n                    const delay = retryAfter || (item.retryDelay * Math.pow(2, attempt - 1) * 2); // Backoff esponenziale più aggressivo\r\n\r\n                    console.log(`[OpenAI Queue] Rate limit rilevato per richiesta ${item.id}, attesa ${delay}ms prima del retry`);\r\n\r\n                    if (attempt < item.maxRetries) {\r\n                        await this.delay(delay);\r\n                        continue; // Riprova\r\n                    }\r\n                } else {\r\n                    // Per altri errori, verifica se sono retryable\r\n                    if (!this.isRetryableError(error)) {\r\n                        console.log(`[OpenAI Queue] Errore non retryable per richiesta ${item.id}:`, error.message);\r\n                        throw error; // Non ritentare\r\n                    }\r\n\r\n                    // Backoff esponenziale standard\r\n                    if (attempt < item.maxRetries) {\r\n                        const delay = item.retryDelay * Math.pow(2, attempt - 1);\r\n                        console.log(`[OpenAI Queue] Errore per richiesta ${item.id}, retry tra ${delay}ms`);\r\n                        await this.delay(delay);\r\n                        continue; // Riprova\r\n                    }\r\n                }\r\n\r\n                // Se siamo all'ultimo tentativo, lancia l'errore\r\n                if (attempt === item.maxRetries) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(`[OpenAI Queue] Richiesta ${item.id} fallita dopo ${item.attempts} tentativi:`, lastError.message);\r\n        throw lastError;\r\n    }\r\n\r\n    /**\r\n     * Verifica se un errore è un rate limit\r\n     * @param {Error} error - Errore da verificare\r\n     * @returns {boolean}\r\n     */\r\n    isRateLimitError(error) {\r\n        if (!error) return false;\r\n\r\n        const message = error.message || '';\r\n        const status = error.status || error.statusCode || 0;\r\n\r\n        return (\r\n            status === 429 ||\r\n            message.includes('rate limit') ||\r\n            message.includes('rate_limit') ||\r\n            message.includes('Limite') ||\r\n            message.includes('too many requests') ||\r\n            message.includes('quota') ||\r\n            message.includes('Quota')\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Estrae il valore retry-after da un errore\r\n     * @param {Error} error - Errore\r\n     * @returns {number|null} Millisecondi da attendere\r\n     */\r\n    extractRetryAfter(error) {\r\n        if (error.headers && error.headers['retry-after']) {\r\n            return parseInt(error.headers['retry-after']) * 1000;\r\n        }\r\n        if (error.retryAfter) {\r\n            return error.retryAfter * 1000;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Verifica se un errore è retryable\r\n     * @param {Error} error - Errore da verificare\r\n     * @returns {boolean}\r\n     */\r\n    isRetryableError(error) {\r\n        if (!error) return false;\r\n\r\n        const status = error.status || error.statusCode || 0;\r\n        const message = error.message || '';\r\n\r\n        // Non ritentare su errori di validazione, autenticazione, autorizzazione\r\n        if ([400, 401, 403].includes(status)) {\r\n            return false;\r\n        }\r\n\r\n        // Non ritentare su errori di formato\r\n        if (message.includes('invalid') || message.includes('Invalid')) {\r\n            return false;\r\n        }\r\n\r\n        // Ritenta su errori di rete, timeout, server errors\r\n        return [408, 429, 500, 502, 503, 504].includes(status) || \r\n               message.includes('timeout') ||\r\n               message.includes('network') ||\r\n               message.includes('ECONNRESET') ||\r\n               message.includes('ETIMEDOUT');\r\n    }\r\n\r\n    /**\r\n     * Delay helper\r\n     * @param {number} ms - Millisecondi da attendere\r\n     * @returns {Promise}\r\n     */\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    /**\r\n     * Ottiene statistiche della coda\r\n     * @returns {Object} Statistiche\r\n     */\r\n    getStats() {\r\n        return {\r\n            queueLength: this.queue.length,\r\n            processing: this.processing,\r\n            limiterStats: {\r\n                running: limiter.running(),\r\n                done: limiter.done(),\r\n                queued: limiter.queued(),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Pulisce la coda\r\n     */\r\n    clear() {\r\n        this.queue = [];\r\n        this.processing = false;\r\n    }\r\n}\r\n\r\n// Istanza singleton\r\nconst openAIQueue = new OpenAIQueue();\r\n\r\nexport default openAIQueue;\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/jurit/OneDrive/Desktop/sito%20upscale/pages/api/tools/translate-document.js"],"sourcesContent":["import formidable from 'formidable';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport mammoth from 'mammoth';\r\nimport PDFDocument from 'pdfkit';\r\nimport OpenAI from 'openai';\r\nimport Tesseract from 'tesseract.js';\r\nimport sharp from 'sharp';\r\nimport pdfParse from 'pdf-parse';\r\nimport openAIQueue from '../../../lib/openai-queue.js';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const config = {\r\n    api: {\r\n        bodyParser: false,\r\n    },\r\n};\r\n\r\n// Funzione per estrarre testo da diversi formati\r\nasync function extractText(filePath, mimeType, originalFilename) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (mimeType === 'application/pdf' || ext === '.pdf') {\r\n        // Estrazione testo da PDF usando pdf-parse con fallback OCR\r\n        let text = '';\r\n        let numPages = 1;\r\n        \r\n        // Tentativo 1: pdf-parse per PDF con testo nativo\r\n        try {\r\n            console.log('[PDF Extract] Inizio estrazione PDF:', originalFilename);\r\n            \r\n            const dataBuffer = fs.readFileSync(filePath);\r\n            console.log('[PDF Extract] Buffer letto, dimensione:', dataBuffer.length, 'bytes');\r\n            \r\n            const result = await pdfParse(dataBuffer);\r\n            console.log('[PDF Extract] Parsing completato, testo estratto:', result?.text?.length || 0, 'caratteri');\r\n            console.log('[PDF Extract] Numero pagine:', result?.numpages || 1);\r\n            \r\n            text = (result && result.text) ? result.text.trim() : '';\r\n            numPages = result?.numpages || 1;\r\n        } catch (pdfError) {\r\n            console.log('[PDF Extract] pdf-parse fallito:', pdfError.message);\r\n            console.error('[PDF Extract] Stack:', pdfError.stack);\r\n            text = ''; // Continua con OCR\r\n        }\r\n\r\n        // Tentativo 2: OCR se pdf-parse ha fallito o testo insufficiente\r\n        // Riduciamo la soglia minima a 10 caratteri per essere meno restrittivi\r\n        if (!text || text.trim().length < 10) {\r\n            console.log('[PDF Extract] Testo insufficiente, uso OCR automatico...');\r\n            try {\r\n                const dataBuffer = fs.readFileSync(filePath);\r\n                const allTexts = [];\r\n                \r\n                // Converti ogni pagina del PDF in immagine e fai OCR\r\n                console.log('[PDF Extract] Conversione PDF in immagini per OCR...');\r\n                \r\n                // Sharp potrebbe non supportare PDF direttamente senza librerie native\r\n                // Proviamo diversi approcci per convertire PDF in immagine\r\n                console.log('[PDF Extract] Conversione prima pagina PDF in immagine per OCR...');\r\n                \r\n                let imageBuffer = null;\r\n                \r\n                // Tentativo 1: Sharp con pages: 1 (plurale)\r\n                try {\r\n                    console.log('[PDF Extract] Tentativo 1: Sharp con pages: 1');\r\n                    imageBuffer = await sharp(dataBuffer, {\r\n                        density: 300,\r\n                        pages: 1\r\n                    })\r\n                    .png()\r\n                    .toBuffer();\r\n                    console.log('[PDF Extract] Successo con pages: 1');\r\n                } catch (sharpError1) {\r\n                    console.log('[PDF Extract] Fallito con pages: 1, errore:', sharpError1.message);\r\n                    \r\n                    // Tentativo 2: Sharp con page: 0 (singolare, 0-based)\r\n                    try {\r\n                        console.log('[PDF Extract] Tentativo 2: Sharp con page: 0');\r\n                        imageBuffer = await sharp(dataBuffer, {\r\n                            density: 300,\r\n                            page: 0\r\n                        })\r\n                        .png()\r\n                        .toBuffer();\r\n                        console.log('[PDF Extract] Successo con page: 0');\r\n                    } catch (sharpError2) {\r\n                        console.log('[PDF Extract] Fallito con page: 0, errore:', sharpError2.message);\r\n                        \r\n                        // Tentativo 3: Sharp senza specificare pagina (prima pagina di default)\r\n                        try {\r\n                            console.log('[PDF Extract] Tentativo 3: Sharp senza specificare pagina');\r\n                            imageBuffer = await sharp(dataBuffer, {\r\n                                density: 300\r\n                            })\r\n                            .png()\r\n                            .toBuffer();\r\n                            console.log('[PDF Extract] Successo senza specificare pagina');\r\n                        } catch (sharpError3) {\r\n                            console.error('[PDF Extract] Tutti i tentativi Sharp falliti');\r\n                            console.error('[PDF Extract] Errore finale:', sharpError3.message);\r\n                            \r\n                            // Se Sharp non può processare il PDF, usiamo OpenAI come fallback (stesso metodo dei documenti AI)\r\n                            console.log('[PDF Extract] Sharp fallito, uso OpenAI per estrazione testo (stesso metodo documenti AI)');\r\n                            try {\r\n                                const { extractTextFromPdfWithOpenAI } = await import('../../../lib/openai.js');\r\n                                \r\n                                // Salva temporaneamente il file per l'upload\r\n                                const os = await import('os');\r\n                                const tempDir = os.tmpdir();\r\n                                const tempFilePath = path.join(tempDir, `temp_${Date.now()}_${originalFilename}`);\r\n                                \r\n                                try {\r\n                                    // Scrivi il buffer su file temporaneo\r\n                                    fs.writeFileSync(tempFilePath, dataBuffer);\r\n                                    \r\n                                    // Estrai testo con OpenAI usando la queue (stesso metodo dei documenti AI)\r\n                                    console.log('[PDF Extract] Aggiungo richiesta estrazione testo alla queue OpenAI');\r\n                                    const openaiText = await openAIQueue.add(\r\n                                        async () => {\r\n                                            return await extractTextFromPdfWithOpenAI(tempFilePath);\r\n                                        },\r\n                                        {\r\n                                            priority: 7, // Priorità alta per estrazione testo\r\n                                            maxRetries: 3,\r\n                                            id: `extract_${Date.now()}`,\r\n                                        }\r\n                                    );\r\n                                    \r\n                                    if (openaiText && openaiText.trim().length > 0) {\r\n                                        console.log('[OpenAI] Testo estratto dal PDF:', openaiText.trim().length, 'caratteri');\r\n                                        return openaiText.trim();\r\n                                    } else {\r\n                                        throw new Error('OpenAI non ha estratto testo dal PDF');\r\n                                    }\r\n                                } finally {\r\n                                    // Pulisci file temporaneo\r\n                                    try {\r\n                                        if (fs.existsSync(tempFilePath)) {\r\n                                            fs.unlinkSync(tempFilePath);\r\n                                        }\r\n                                    } catch (cleanupError) {\r\n                                        console.warn('Errore pulizia file temporaneo:', cleanupError);\r\n                                    }\r\n                                }\r\n                            } catch (openaiError) {\r\n                                console.error('[OpenAI] Estrazione testo fallita:', openaiError.message);\r\n                                \r\n                                // Verifica se è un errore di rate limit\r\n                                const isRateLimit = openaiError.message && (\r\n                                    openaiError.message.includes('rate') || \r\n                                    openaiError.message.includes('Limite') ||\r\n                                    openaiError.message.includes('429')\r\n                                );\r\n                                \r\n                                if (isRateLimit) {\r\n                                    console.log('[OpenAI] Rate limit raggiunto, provo OCR diretto come alternativa');\r\n                                }\r\n                                \r\n                                // Ultimo tentativo: OCR diretto sul PDF con Tesseract\r\n                                console.log('[PDF Extract] Tentativo finale: OCR diretto sul PDF');\r\n                                try {\r\n                                    const { data: { text: directOcrText } } = await Tesseract.recognize(\r\n                                        dataBuffer,\r\n                                        'ita+eng',\r\n                                        {\r\n                                            logger: m => {\r\n                                                if (m.status === 'recognizing text') {\r\n                                                    console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                    \r\n                                    if (directOcrText && directOcrText.trim().length > 0) {\r\n                                        console.log('[OCR] Testo estratto direttamente dal PDF:', directOcrText.trim().length, 'caratteri');\r\n                                        return directOcrText.trim();\r\n                                    } else {\r\n                                        throw new Error('OCR diretto non ha estratto testo');\r\n                                    }\r\n                                } catch (directOcrError) {\r\n                                    console.error('[OCR] OCR diretto fallito:', directOcrError.message);\r\n                                    \r\n                                    // Costruisci messaggio di errore più informativo e utile\r\n                                    let errorMessage = '';\r\n                                    let suggestions = [];\r\n                                    \r\n                                    if (isRateLimit) {\r\n                                        errorMessage = 'OpenAI ha raggiunto il limite di richieste. ';\r\n                                        suggestions = [\r\n                                            'Attendi 1-2 minuti e riprova',\r\n                                            'Prova con un PDF che contiene testo nativo (non solo immagini scansionate)',\r\n                                            'Converti il PDF in DOCX o TXT usando un altro tool prima di tradurlo',\r\n                                            'Prova a estrarre il testo manualmente e incollalo come file TXT'\r\n                                        ];\r\n                                    } else {\r\n                                        errorMessage = 'Impossibile estrarre testo dal PDF. ';\r\n                                        suggestions = [\r\n                                            'Il PDF potrebbe essere protetto o corrotto',\r\n                                            'Il PDF potrebbe contenere solo immagini senza testo estraibile',\r\n                                            'Prova a convertire il PDF in DOCX o TXT usando un altro tool',\r\n                                            'Prova con un PDF diverso che contiene testo nativo'\r\n                                        ];\r\n                                    }\r\n                                    \r\n                                    errorMessage += '\\n\\nCosa puoi fare:\\n';\r\n                                    suggestions.forEach((suggestion, index) => {\r\n                                        errorMessage += `${index + 1}. ${suggestion}\\n`;\r\n                                    });\r\n                                    \r\n                                    errorMessage += '\\nMetodi tentati: pdf-parse, conversione Sharp, estrazione OpenAI, OCR diretto.';\r\n                                    \r\n                                    throw new Error(errorMessage);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Se abbiamo un'immagine, processiamola\r\n                if (imageBuffer) {\r\n                    console.log('[PDF Extract] Immagine ottenuta, dimensione:', imageBuffer.length, 'bytes');\r\n                    \r\n                    try {\r\n                        // Preprocessa l'immagine per migliorare OCR\r\n                        const processedImage = await sharp(imageBuffer)\r\n                            .greyscale()\r\n                            .normalize()\r\n                            .sharpen()\r\n                            .toBuffer();\r\n                        \r\n                        // Esegui OCR sull'immagine\r\n                        console.log('[OCR] Esecuzione OCR sulla prima pagina...');\r\n                        const { data: { text: pageText } } = await Tesseract.recognize(\r\n                            processedImage,\r\n                            'ita+eng',\r\n                            {\r\n                                logger: m => {\r\n                                    if (m.status === 'recognizing text') {\r\n                                        console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        if (pageText && pageText.trim().length > 0) {\r\n                            allTexts.push(pageText.trim());\r\n                            console.log('[OCR] Testo estratto dalla prima pagina:', pageText.trim().length, 'caratteri');\r\n                        } else {\r\n                            throw new Error('OCR non ha estratto testo dall\\'immagine');\r\n                        }\r\n                    } catch (processError) {\r\n                        console.error('[OCR] Errore processando immagine:', processError.message);\r\n                        throw new Error(`Errore durante l'OCR: ${processError.message}`);\r\n                    }\r\n                } else {\r\n                    throw new Error('Impossibile ottenere immagine dal PDF');\r\n                }\r\n                \r\n                if (allTexts.length > 0) {\r\n                    const ocrText = allTexts.join('\\n\\n');\r\n                    console.log('[OCR] Testo totale estratto via OCR:', ocrText.length, 'caratteri da', allTexts.length, 'pagina/e');\r\n                    return ocrText;\r\n                } else {\r\n                    throw new Error('Nessun testo estratto dalle immagini del PDF');\r\n                }\r\n            } catch (ocrError) {\r\n                console.error('[OCR] Errore OCR:', ocrError.message);\r\n                throw new Error(`Errore durante l'estrazione del testo: ${ocrError.message}`);\r\n            }\r\n        }\r\n\r\n        console.log('[PDF Extract] Estrazione completata con successo');\r\n        return text;\r\n    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || ext === '.docx') {\r\n        const result = await mammoth.extractRawText({ path: filePath });\r\n        return result.value;\r\n    } else if (mimeType === 'application/msword' || ext === '.doc') {\r\n        throw new Error('I file .doc non sono supportati. Converti in .docx o .pdf');\r\n    } else if (mimeType === 'text/plain' || ext === '.txt') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else if (mimeType === 'text/markdown' || ext === '.md') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else {\r\n        throw new Error('Formato file non supportato');\r\n    }\r\n}\r\n\r\n// Funzione per tradurre testo usando OpenAI con queue e retry automatico\r\nasync function translateText(text, targetLanguage, preserveFormatting) {\r\n    try {\r\n        const languageNames = {\r\n            'it': 'Italiano',\r\n            'en': 'Inglese',\r\n            'es': 'Spagnolo',\r\n            'fr': 'Francese',\r\n            'de': 'Tedesco',\r\n            'pt': 'Portoghese',\r\n            'ru': 'Russo',\r\n            'ja': 'Giapponese',\r\n            'zh': 'Cinese',\r\n            'ar': 'Arabo'\r\n        };\r\n        \r\n        const targetLangName = languageNames[targetLanguage] || targetLanguage;\r\n        \r\n        const prompt = preserveFormatting \r\n            ? `Traduci il seguente testo in ${targetLangName} mantenendo ESATTAMENTE la stessa formattazione, struttura, interruzioni di riga e spaziatura. Non aggiungere commenti o spiegazioni, restituisci solo il testo tradotto:\\n\\n${text}`\r\n            : `Traduci il seguente testo in ${targetLangName}. Restituisci solo la traduzione senza commenti:\\n\\n${text}`;\r\n        \r\n        // Usa la queue per gestire rate limiting e retry automatico\r\n        console.log('[Translate] Aggiungo richiesta traduzione alla queue OpenAI');\r\n        const translatedText = await openAIQueue.add(\r\n            async () => {\r\n                const response = await openai.chat.completions.create({\r\n                    model: 'gpt-4o-mini',\r\n                    messages: [\r\n                        { role: 'system', content: 'Sei un traduttore professionale. Traduci il testo mantenendo il tono e lo stile originale.' },\r\n                        { role: 'user', content: prompt }\r\n                    ],\r\n                    temperature: 0.3,\r\n                });\r\n                \r\n                return response.choices[0].message.content;\r\n            },\r\n            {\r\n                priority: 8, // Priorità alta per traduzione\r\n                maxRetries: 3,\r\n                id: `translate_${Date.now()}_${targetLanguage}`,\r\n            }\r\n        );\r\n        \r\n        return translatedText;\r\n    } catch (error) {\r\n        console.error('Errore traduzione con OpenAI:', error);\r\n        \r\n        // Se è un errore di rate limit, fornisci un messaggio più chiaro\r\n        if (error.message && (error.message.includes('rate') || error.message.includes('Limite') || error.message.includes('429'))) {\r\n            throw new Error('OpenAI ha raggiunto il limite di richieste. La richiesta è stata messa in coda e verrà riprovata automaticamente. Riprova tra qualche minuto.');\r\n        }\r\n        \r\n        throw new Error(`Errore durante la traduzione del testo: ${error.message || 'Errore sconosciuto'}`);\r\n    }\r\n}\r\n\r\n// Funzione per creare documento tradotto\r\nasync function createTranslatedDocument(originalText, translatedText, originalPath, originalFilename, targetLanguage) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (ext === '.pdf') {\r\n        // Per PDF, creiamo un nuovo PDF con il testo tradotto\r\n        // In produzione, useresti pdf-lib per mantenere meglio la formattazione\r\n        const doc = new PDFDocument();\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.pdf`);\r\n        const stream = fs.createWriteStream(outputPath);\r\n        doc.pipe(stream);\r\n        doc.fontSize(12);\r\n        \r\n        // Dividi il testo in paragrafi per una migliore formattazione\r\n        const paragraphs = translatedText.split('\\n\\n');\r\n        paragraphs.forEach((para, index) => {\r\n            if (index > 0) doc.moveDown();\r\n            doc.text(para, { align: 'left', continued: false });\r\n        });\r\n        \r\n        doc.end();\r\n        \r\n        await new Promise((resolve, reject) => {\r\n            stream.on('finish', resolve);\r\n            stream.on('error', reject);\r\n        });\r\n        \r\n        return fs.readFileSync(outputPath);\r\n    } else if (ext === '.docx') {\r\n        // Per DOCX, creiamo un nuovo documento\r\n        // In produzione, useresti docx o officegen per mantenere la formattazione\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.txt`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    } else {\r\n        // Per TXT e MD, creiamo un nuovo file di testo\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}${ext}`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    }\r\n}\r\n\r\nexport default async function handler(req, res) {\r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    const uploadDir = path.join(process.cwd(), 'uploads');\r\n    if (!fs.existsSync(uploadDir)) {\r\n        fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    const form = formidable({\r\n        uploadDir,\r\n        keepExtensions: true,\r\n        maxFileSize: 50 * 1024 * 1024, // 50MB\r\n    });\r\n\r\n    try {\r\n        const [fields, files] = await new Promise((resolve, reject) => {\r\n            form.parse(req, (err, fields, files) => {\r\n                if (err) reject(err);\r\n                else resolve([fields, files]);\r\n            });\r\n        });\r\n\r\n        const documentFile = Array.isArray(files.document) ? files.document[0] : files.document;\r\n        const targetLanguage = Array.isArray(fields.targetLanguage) ? fields.targetLanguage[0] : fields.targetLanguage || 'en';\r\n        const preserveFormatting = Array.isArray(fields.preserveFormatting) \r\n            ? fields.preserveFormatting[0] === 'true' \r\n            : fields.preserveFormatting === 'true';\r\n\r\n        if (!documentFile) {\r\n            return res.status(400).json({ error: 'Nessun documento caricato' });\r\n        }\r\n\r\n        // Estrai testo dal documento\r\n        const originalText = await extractText(\r\n            documentFile.filepath,\r\n            documentFile.mimetype,\r\n            documentFile.originalFilename\r\n        );\r\n\r\n        if (!originalText || originalText.trim().length === 0) {\r\n            return res.status(400).json({ error: 'Impossibile estrarre testo dal documento' });\r\n        }\r\n\r\n        // Traduci il testo\r\n        const translatedText = await translateText(originalText, targetLanguage, preserveFormatting);\r\n\r\n        // Crea documento tradotto\r\n        const translatedBuffer = await createTranslatedDocument(\r\n            originalText,\r\n            translatedText,\r\n            documentFile.filepath,\r\n            documentFile.originalFilename,\r\n            targetLanguage\r\n        );\r\n\r\n        // Determina il tipo MIME e nome file\r\n        const ext = path.extname(documentFile.originalFilename).toLowerCase();\r\n        let mimeType = 'application/octet-stream';\r\n        let filename = `translated_${targetLanguage}_${documentFile.originalFilename}`;\r\n\r\n        if (ext === '.pdf') {\r\n            mimeType = 'application/pdf';\r\n        } else if (ext === '.docx') {\r\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n        } else if (ext === '.txt') {\r\n            mimeType = 'text/plain';\r\n        } else if (ext === '.md') {\r\n            mimeType = 'text/markdown';\r\n        }\r\n\r\n        // Cleanup\r\n        try {\r\n            fs.unlinkSync(documentFile.filepath);\r\n            // Pulisci anche i file temporanei creati\r\n            const tempFiles = fs.readdirSync(uploadDir).filter(f => f.startsWith('translated_'));\r\n            tempFiles.forEach(f => {\r\n                try {\r\n                    fs.unlinkSync(path.join(uploadDir, f));\r\n                } catch (e) {}\r\n            });\r\n        } catch (e) {\r\n            console.error('Errore cleanup:', e);\r\n        }\r\n\r\n        res.setHeader('Content-Type', mimeType);\r\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);\r\n        res.status(200).send(translatedBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Traduzione Documenti:', error);\r\n        console.error('Stack trace:', error.stack);\r\n        console.error('Error details:', {\r\n            message: error.message,\r\n            name: error.name,\r\n            code: error.code\r\n        });\r\n        \r\n        // Determina il messaggio di errore appropriato\r\n        let errorMessage = 'Errore durante la traduzione del documento. Riprova con un file diverso.';\r\n        \r\n        if (error.message) {\r\n            errorMessage = error.message;\r\n        } else if (error.code === 'ENOENT') {\r\n            errorMessage = 'File non trovato. Assicurati di aver caricato un file valido.';\r\n        } else if (error.code === 'LIMIT_FILE_SIZE') {\r\n            errorMessage = 'File troppo grande. Dimensione massima: 50MB.';\r\n        }\r\n        \r\n        res.status(500).json({ \r\n            error: errorMessage,\r\n            details: process.env.NODE_ENV === 'development' ? error.stack : undefined\r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}