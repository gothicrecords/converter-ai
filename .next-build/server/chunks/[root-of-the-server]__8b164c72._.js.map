{"version":3,"sources":["../../../lib/openai-queue.js","../../../pages/api/tools/translate-document.js","../../../node_modules/next/src/build/templates/pages-api.ts"],"sourcesContent":["// Sistema di queue con retry automatico e rate limiting per OpenAI\r\nimport Bottleneck from 'bottleneck';\r\n\r\n// Configurazione rate limiter per OpenAI\r\n// OpenAI ha limiti: \r\n// - GPT-4o: 10 RPM (requests per minute) per tier gratuito\r\n// - GPT-4o-mini: 500 RPM per tier gratuito\r\n// Usiamo valori conservativi per evitare rate limits\r\nconst limiter = new Bottleneck({\r\n    reservoir: 50, // Numero di richieste disponibili\r\n    reservoirRefreshAmount: 50, // Ricarica ogni intervallo\r\n    reservoirRefreshInterval: 60 * 1000, // 1 minuto\r\n    maxConcurrent: 3, // Massimo 3 richieste concorrenti\r\n    minTime: 200, // Minimo 200ms tra le richieste\r\n});\r\n\r\n// Queue per le richieste con retry automatico\r\nclass OpenAIQueue {\r\n    constructor() {\r\n        this.queue = [];\r\n        this.processing = false;\r\n        this.maxRetries = 3;\r\n        this.baseDelay = 1000; // 1 secondo base delay\r\n    }\r\n\r\n    /**\r\n     * Aggiunge una richiesta alla coda con retry automatico\r\n     * @param {Function} operation - Funzione async da eseguire\r\n     * @param {Object} options - Opzioni per la richiesta\r\n     * @returns {Promise} Promise che si risolve con il risultato\r\n     */\r\n    async add(operation, options = {}) {\r\n        const {\r\n            priority = 5, // Priorità (1-10, più alto = più prioritario)\r\n            maxRetries = this.maxRetries,\r\n            retryDelay = this.baseDelay,\r\n            id = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        } = options;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const queueItem = {\r\n                id,\r\n                operation,\r\n                priority,\r\n                maxRetries,\r\n                retryDelay,\r\n                attempts: 0,\r\n                resolve,\r\n                reject,\r\n                timestamp: Date.now(),\r\n            };\r\n\r\n            this.queue.push(queueItem);\r\n            this.queue.sort((a, b) => b.priority - a.priority); // Ordina per priorità\r\n\r\n            // Avvia il processing se non è già in corso\r\n            if (!this.processing) {\r\n                this.processQueue();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Processa la coda delle richieste\r\n     */\r\n    async processQueue() {\r\n        if (this.processing || this.queue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.processing = true;\r\n\r\n        while (this.queue.length > 0) {\r\n            const item = this.queue.shift();\r\n\r\n            try {\r\n                // Esegui l'operazione con rate limiting\r\n                const result = await limiter.schedule(async () => {\r\n                    return await this.executeWithRetry(item);\r\n                });\r\n\r\n                item.resolve(result);\r\n            } catch (error) {\r\n                // Se tutti i retry sono falliti, rifiuta la promise\r\n                item.reject(error);\r\n            }\r\n        }\r\n\r\n        this.processing = false;\r\n    }\r\n\r\n    /**\r\n     * Esegue un'operazione con retry automatico e backoff esponenziale\r\n     * @param {Object} item - Item della coda\r\n     * @returns {Promise} Risultato dell'operazione\r\n     */\r\n    async executeWithRetry(item) {\r\n        let lastError;\r\n\r\n        for (let attempt = 1; attempt <= item.maxRetries; attempt++) {\r\n            try {\r\n                item.attempts = attempt;\r\n                console.log(`[OpenAI Queue] Tentativo ${attempt}/${item.maxRetries} per richiesta ${item.id}`);\r\n\r\n                const result = await item.operation();\r\n                console.log(`[OpenAI Queue] Richiesta ${item.id} completata con successo`);\r\n                return result;\r\n            } catch (error) {\r\n                lastError = error;\r\n\r\n                // Verifica se è un errore di rate limit\r\n                const isRateLimit = this.isRateLimitError(error);\r\n\r\n                if (isRateLimit) {\r\n                    // Per rate limit, usa un delay più lungo\r\n                    const retryAfter = this.extractRetryAfter(error);\r\n                    const delay = retryAfter || (item.retryDelay * Math.pow(2, attempt - 1) * 2); // Backoff esponenziale più aggressivo\r\n\r\n                    console.log(`[OpenAI Queue] Rate limit rilevato per richiesta ${item.id}, attesa ${delay}ms prima del retry`);\r\n\r\n                    if (attempt < item.maxRetries) {\r\n                        await this.delay(delay);\r\n                        continue; // Riprova\r\n                    }\r\n                } else {\r\n                    // Per altri errori, verifica se sono retryable\r\n                    if (!this.isRetryableError(error)) {\r\n                        console.log(`[OpenAI Queue] Errore non retryable per richiesta ${item.id}:`, error.message);\r\n                        throw error; // Non ritentare\r\n                    }\r\n\r\n                    // Backoff esponenziale standard\r\n                    if (attempt < item.maxRetries) {\r\n                        const delay = item.retryDelay * Math.pow(2, attempt - 1);\r\n                        console.log(`[OpenAI Queue] Errore per richiesta ${item.id}, retry tra ${delay}ms`);\r\n                        await this.delay(delay);\r\n                        continue; // Riprova\r\n                    }\r\n                }\r\n\r\n                // Se siamo all'ultimo tentativo, lancia l'errore\r\n                if (attempt === item.maxRetries) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        console.error(`[OpenAI Queue] Richiesta ${item.id} fallita dopo ${item.attempts} tentativi:`, lastError.message);\r\n        throw lastError;\r\n    }\r\n\r\n    /**\r\n     * Verifica se un errore è un rate limit\r\n     * @param {Error} error - Errore da verificare\r\n     * @returns {boolean}\r\n     */\r\n    isRateLimitError(error) {\r\n        if (!error) return false;\r\n\r\n        const message = error.message || '';\r\n        const status = error.status || error.statusCode || 0;\r\n\r\n        return (\r\n            status === 429 ||\r\n            message.includes('rate limit') ||\r\n            message.includes('rate_limit') ||\r\n            message.includes('Limite') ||\r\n            message.includes('too many requests') ||\r\n            message.includes('quota') ||\r\n            message.includes('Quota')\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Estrae il valore retry-after da un errore\r\n     * @param {Error} error - Errore\r\n     * @returns {number|null} Millisecondi da attendere\r\n     */\r\n    extractRetryAfter(error) {\r\n        if (error.headers && error.headers['retry-after']) {\r\n            return parseInt(error.headers['retry-after']) * 1000;\r\n        }\r\n        if (error.retryAfter) {\r\n            return error.retryAfter * 1000;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Verifica se un errore è retryable\r\n     * @param {Error} error - Errore da verificare\r\n     * @returns {boolean}\r\n     */\r\n    isRetryableError(error) {\r\n        if (!error) return false;\r\n\r\n        const status = error.status || error.statusCode || 0;\r\n        const message = error.message || '';\r\n\r\n        // Non ritentare su errori di validazione, autenticazione, autorizzazione\r\n        if ([400, 401, 403].includes(status)) {\r\n            return false;\r\n        }\r\n\r\n        // Non ritentare su errori di formato\r\n        if (message.includes('invalid') || message.includes('Invalid')) {\r\n            return false;\r\n        }\r\n\r\n        // Ritenta su errori di rete, timeout, server errors\r\n        return [408, 429, 500, 502, 503, 504].includes(status) || \r\n               message.includes('timeout') ||\r\n               message.includes('network') ||\r\n               message.includes('ECONNRESET') ||\r\n               message.includes('ETIMEDOUT');\r\n    }\r\n\r\n    /**\r\n     * Delay helper\r\n     * @param {number} ms - Millisecondi da attendere\r\n     * @returns {Promise}\r\n     */\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    /**\r\n     * Ottiene statistiche della coda\r\n     * @returns {Object} Statistiche\r\n     */\r\n    getStats() {\r\n        return {\r\n            queueLength: this.queue.length,\r\n            processing: this.processing,\r\n            limiterStats: {\r\n                running: limiter.running(),\r\n                done: limiter.done(),\r\n                queued: limiter.queued(),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Pulisce la coda\r\n     */\r\n    clear() {\r\n        this.queue = [];\r\n        this.processing = false;\r\n    }\r\n}\r\n\r\n// Istanza singleton\r\nconst openAIQueue = new OpenAIQueue();\r\n\r\nexport default openAIQueue;\r\n\r\n","import formidable from 'formidable';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport os from 'os';\r\nimport mammoth from 'mammoth';\r\nimport PDFDocument from 'pdfkit';\r\nimport OpenAI from 'openai';\r\nimport Tesseract from 'tesseract.js';\r\nimport sharp from 'sharp';\r\nimport pdfParse from 'pdf-parse';\r\nimport openAIQueue from '../../../lib/openai-queue.js';\r\nimport { canUseTool, getUpgradeMessage } from '../../../lib/usage-limits.js';\r\nimport { getUsageStats, incrementUsage, getUserPlan, getUserId } from '../../../lib/usage-tracker.js';\r\n\r\nconst openai = new OpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nexport const config = {\r\n    api: {\r\n        bodyParser: false,\r\n    },\r\n};\r\n\r\n// Funzione per estrarre testo da diversi formati\r\nasync function extractText(filePath, mimeType, originalFilename) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (mimeType === 'application/pdf' || ext === '.pdf') {\r\n        // Estrazione testo da PDF usando pdf-parse con fallback OCR\r\n        let text = '';\r\n        let numPages = 1;\r\n        \r\n        // Tentativo 1: pdf-parse per PDF con testo nativo\r\n        try {\r\n            console.log('[PDF Extract] Inizio estrazione PDF:', originalFilename);\r\n            \r\n            const dataBuffer = fs.readFileSync(filePath);\r\n            console.log('[PDF Extract] Buffer letto, dimensione:', dataBuffer.length, 'bytes');\r\n            \r\n            const result = await pdfParse(dataBuffer);\r\n            console.log('[PDF Extract] Parsing completato, testo estratto:', result?.text?.length || 0, 'caratteri');\r\n            console.log('[PDF Extract] Numero pagine:', result?.numpages || 1);\r\n            \r\n            text = (result && result.text) ? result.text.trim() : '';\r\n            numPages = result?.numpages || 1;\r\n        } catch (pdfError) {\r\n            console.log('[PDF Extract] pdf-parse fallito:', pdfError.message);\r\n            console.error('[PDF Extract] Stack:', pdfError.stack);\r\n            text = ''; // Continua con OCR\r\n        }\r\n\r\n        // Tentativo 2: OCR se pdf-parse ha fallito o testo insufficiente\r\n        // Riduciamo la soglia minima a 10 caratteri per essere meno restrittivi\r\n        if (!text || text.trim().length < 10) {\r\n            console.log('[PDF Extract] Testo insufficiente, uso OCR automatico...');\r\n            try {\r\n                const dataBuffer = fs.readFileSync(filePath);\r\n                const allTexts = [];\r\n                \r\n                // Converti ogni pagina del PDF in immagine e fai OCR\r\n                console.log('[PDF Extract] Conversione PDF in immagini per OCR...');\r\n                \r\n                // Sharp potrebbe non supportare PDF direttamente senza librerie native\r\n                // Proviamo diversi approcci per convertire PDF in immagine\r\n                console.log('[PDF Extract] Conversione prima pagina PDF in immagine per OCR...');\r\n                \r\n                let imageBuffer = null;\r\n                \r\n                // Tentativo 1: Sharp con pages: 1 (plurale)\r\n                try {\r\n                    console.log('[PDF Extract] Tentativo 1: Sharp con pages: 1');\r\n                    imageBuffer = await sharp(dataBuffer, {\r\n                        density: 300,\r\n                        pages: 1\r\n                    })\r\n                    .png()\r\n                    .toBuffer();\r\n                    console.log('[PDF Extract] Successo con pages: 1');\r\n                } catch (sharpError1) {\r\n                    console.log('[PDF Extract] Fallito con pages: 1, errore:', sharpError1.message);\r\n                    \r\n                    // Tentativo 2: Sharp con page: 0 (singolare, 0-based)\r\n                    try {\r\n                        console.log('[PDF Extract] Tentativo 2: Sharp con page: 0');\r\n                        imageBuffer = await sharp(dataBuffer, {\r\n                            density: 300,\r\n                            page: 0\r\n                        })\r\n                        .png()\r\n                        .toBuffer();\r\n                        console.log('[PDF Extract] Successo con page: 0');\r\n                    } catch (sharpError2) {\r\n                        console.log('[PDF Extract] Fallito con page: 0, errore:', sharpError2.message);\r\n                        \r\n                        // Tentativo 3: Sharp senza specificare pagina (prima pagina di default)\r\n                        try {\r\n                            console.log('[PDF Extract] Tentativo 3: Sharp senza specificare pagina');\r\n                            imageBuffer = await sharp(dataBuffer, {\r\n                                density: 300\r\n                            })\r\n                            .png()\r\n                            .toBuffer();\r\n                            console.log('[PDF Extract] Successo senza specificare pagina');\r\n                        } catch (sharpError3) {\r\n                            console.error('[PDF Extract] Tutti i tentativi Sharp falliti');\r\n                            console.error('[PDF Extract] Errore finale:', sharpError3.message);\r\n                            \r\n                            // Se Sharp non può processare il PDF, usiamo OpenAI come fallback (stesso metodo dei documenti AI)\r\n                            console.log('[PDF Extract] Sharp fallito, uso OpenAI per estrazione testo (stesso metodo documenti AI)');\r\n                            try {\r\n                                const { extractTextFromPdfWithOpenAI } = await import('../../../lib/openai.js');\r\n                                \r\n                                // Salva temporaneamente il file per l'upload\r\n                                const os = await import('os');\r\n                                const tempDir = os.tmpdir();\r\n                                const tempFilePath = path.join(tempDir, `temp_${Date.now()}_${originalFilename}`);\r\n                                \r\n                                try {\r\n                                    // Scrivi il buffer su file temporaneo\r\n                                    fs.writeFileSync(tempFilePath, dataBuffer);\r\n                                    \r\n                                    // Estrai testo con OpenAI usando la queue (stesso metodo dei documenti AI)\r\n                                    console.log('[PDF Extract] Aggiungo richiesta estrazione testo alla queue OpenAI');\r\n                                    const openaiText = await openAIQueue.add(\r\n                                        async () => {\r\n                                            return await extractTextFromPdfWithOpenAI(tempFilePath);\r\n                                        },\r\n                                        {\r\n                                            priority: 7, // Priorità alta per estrazione testo\r\n                                            maxRetries: 3,\r\n                                            id: `extract_${Date.now()}`,\r\n                                        }\r\n                                    );\r\n                                    \r\n                                    if (openaiText && openaiText.trim().length > 0) {\r\n                                        console.log('[OpenAI] Testo estratto dal PDF:', openaiText.trim().length, 'caratteri');\r\n                                        return openaiText.trim();\r\n                                    } else {\r\n                                        throw new Error('OpenAI non ha estratto testo dal PDF');\r\n                                    }\r\n                                } finally {\r\n                                    // Pulisci file temporaneo\r\n                                    try {\r\n                                        if (fs.existsSync(tempFilePath)) {\r\n                                            fs.unlinkSync(tempFilePath);\r\n                                        }\r\n                                    } catch (cleanupError) {\r\n                                        console.warn('Errore pulizia file temporaneo:', cleanupError);\r\n                                    }\r\n                                }\r\n                            } catch (openaiError) {\r\n                                console.error('[OpenAI] Estrazione testo fallita:', openaiError.message);\r\n                                \r\n                                // Verifica se è un errore di rate limit\r\n                                const isRateLimit = openaiError.message && (\r\n                                    openaiError.message.includes('rate') || \r\n                                    openaiError.message.includes('Limite') ||\r\n                                    openaiError.message.includes('429')\r\n                                );\r\n                                \r\n                                if (isRateLimit) {\r\n                                    console.log('[OpenAI] Rate limit raggiunto, provo OCR diretto come alternativa');\r\n                                }\r\n                                \r\n                                // Ultimo tentativo: OCR diretto sul PDF con Tesseract\r\n                                console.log('[PDF Extract] Tentativo finale: OCR diretto sul PDF');\r\n                                try {\r\n                                    const { data: { text: directOcrText } } = await Tesseract.recognize(\r\n                                        dataBuffer,\r\n                                        'ita+eng',\r\n                                        {\r\n                                            logger: m => {\r\n                                                if (m.status === 'recognizing text') {\r\n                                                    console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    );\r\n                                    \r\n                                    if (directOcrText && directOcrText.trim().length > 0) {\r\n                                        console.log('[OCR] Testo estratto direttamente dal PDF:', directOcrText.trim().length, 'caratteri');\r\n                                        return directOcrText.trim();\r\n                                    } else {\r\n                                        throw new Error('OCR diretto non ha estratto testo');\r\n                                    }\r\n                                } catch (directOcrError) {\r\n                                    console.error('[OCR] OCR diretto fallito:', directOcrError.message);\r\n                                    \r\n                                    // Costruisci messaggio di errore più informativo e utile\r\n                                    let errorMessage = '';\r\n                                    let suggestions = [];\r\n                                    \r\n                                    if (isRateLimit) {\r\n                                        errorMessage = 'OpenAI ha raggiunto il limite di richieste. ';\r\n                                        suggestions = [\r\n                                            'Attendi 1-2 minuti e riprova',\r\n                                            'Prova con un PDF che contiene testo nativo (non solo immagini scansionate)',\r\n                                            'Converti il PDF in DOCX o TXT usando un altro tool prima di tradurlo',\r\n                                            'Prova a estrarre il testo manualmente e incollalo come file TXT'\r\n                                        ];\r\n                                    } else {\r\n                                        errorMessage = 'Impossibile estrarre testo dal PDF. ';\r\n                                        suggestions = [\r\n                                            'Il PDF potrebbe essere protetto o corrotto',\r\n                                            'Il PDF potrebbe contenere solo immagini senza testo estraibile',\r\n                                            'Prova a convertire il PDF in DOCX o TXT usando un altro tool',\r\n                                            'Prova con un PDF diverso che contiene testo nativo'\r\n                                        ];\r\n                                    }\r\n                                    \r\n                                    errorMessage += '\\n\\nCosa puoi fare:\\n';\r\n                                    suggestions.forEach((suggestion, index) => {\r\n                                        errorMessage += `${index + 1}. ${suggestion}\\n`;\r\n                                    });\r\n                                    \r\n                                    errorMessage += '\\nMetodi tentati: pdf-parse, conversione Sharp, estrazione OpenAI, OCR diretto.';\r\n                                    \r\n                                    throw new Error(errorMessage);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // Se abbiamo un'immagine, processiamola\r\n                if (imageBuffer) {\r\n                    console.log('[PDF Extract] Immagine ottenuta, dimensione:', imageBuffer.length, 'bytes');\r\n                    \r\n                    try {\r\n                        // Preprocessa l'immagine per migliorare OCR\r\n                        const processedImage = await sharp(imageBuffer)\r\n                            .greyscale()\r\n                            .normalize()\r\n                            .sharpen()\r\n                            .toBuffer();\r\n                        \r\n                        // Esegui OCR sull'immagine\r\n                        console.log('[OCR] Esecuzione OCR sulla prima pagina...');\r\n                        const { data: { text: pageText } } = await Tesseract.recognize(\r\n                            processedImage,\r\n                            'ita+eng',\r\n                            {\r\n                                logger: m => {\r\n                                    if (m.status === 'recognizing text') {\r\n                                        console.log(`[OCR] Progress: ${Math.round(m.progress * 100)}%`);\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        \r\n                        if (pageText && pageText.trim().length > 0) {\r\n                            allTexts.push(pageText.trim());\r\n                            console.log('[OCR] Testo estratto dalla prima pagina:', pageText.trim().length, 'caratteri');\r\n                        } else {\r\n                            throw new Error('OCR non ha estratto testo dall\\'immagine');\r\n                        }\r\n                    } catch (processError) {\r\n                        console.error('[OCR] Errore processando immagine:', processError.message);\r\n                        throw new Error(`Errore durante l'OCR: ${processError.message}`);\r\n                    }\r\n                } else {\r\n                    throw new Error('Impossibile ottenere immagine dal PDF');\r\n                }\r\n                \r\n                if (allTexts.length > 0) {\r\n                    const ocrText = allTexts.join('\\n\\n');\r\n                    console.log('[OCR] Testo totale estratto via OCR:', ocrText.length, 'caratteri da', allTexts.length, 'pagina/e');\r\n                    return ocrText;\r\n                } else {\r\n                    throw new Error('Nessun testo estratto dalle immagini del PDF');\r\n                }\r\n            } catch (ocrError) {\r\n                console.error('[OCR] Errore OCR:', ocrError.message);\r\n                throw new Error(`Errore durante l'estrazione del testo: ${ocrError.message}`);\r\n            }\r\n        }\r\n\r\n        console.log('[PDF Extract] Estrazione completata con successo');\r\n        return text;\r\n    } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || ext === '.docx') {\r\n        const result = await mammoth.extractRawText({ path: filePath });\r\n        return result.value;\r\n    } else if (mimeType === 'application/msword' || ext === '.doc') {\r\n        throw new Error('I file .doc non sono supportati. Converti in .docx o .pdf');\r\n    } else if (mimeType === 'text/plain' || ext === '.txt') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else if (mimeType === 'text/markdown' || ext === '.md') {\r\n        return fs.readFileSync(filePath, 'utf-8');\r\n    } else {\r\n        throw new Error('Formato file non supportato');\r\n    }\r\n}\r\n\r\n// Funzione per tradurre testo usando OpenAI con queue e retry automatico\r\nasync function translateText(text, targetLanguage, preserveFormatting) {\r\n    try {\r\n        const languageNames = {\r\n            'it': 'Italiano',\r\n            'en': 'Inglese',\r\n            'es': 'Spagnolo',\r\n            'fr': 'Francese',\r\n            'de': 'Tedesco',\r\n            'pt': 'Portoghese',\r\n            'ru': 'Russo',\r\n            'ja': 'Giapponese',\r\n            'zh': 'Cinese',\r\n            'ar': 'Arabo'\r\n        };\r\n        \r\n        const targetLangName = languageNames[targetLanguage] || targetLanguage;\r\n        \r\n        const prompt = preserveFormatting \r\n            ? `Traduci il seguente testo in ${targetLangName} mantenendo ESATTAMENTE la stessa formattazione, struttura, interruzioni di riga e spaziatura. Non aggiungere commenti o spiegazioni, restituisci solo il testo tradotto:\\n\\n${text}`\r\n            : `Traduci il seguente testo in ${targetLangName}. Restituisci solo la traduzione senza commenti:\\n\\n${text}`;\r\n        \r\n        // Usa la queue per gestire rate limiting e retry automatico\r\n        console.log('[Translate] Aggiungo richiesta traduzione alla queue OpenAI');\r\n        const translatedText = await openAIQueue.add(\r\n            async () => {\r\n                const response = await openai.chat.completions.create({\r\n                    model: 'gpt-4o-mini',\r\n                    messages: [\r\n                        { role: 'system', content: 'Sei un traduttore professionale. Traduci il testo mantenendo il tono e lo stile originale.' },\r\n                        { role: 'user', content: prompt }\r\n                    ],\r\n                    temperature: 0.3,\r\n                });\r\n                \r\n                return response.choices[0].message.content;\r\n            },\r\n            {\r\n                priority: 8, // Priorità alta per traduzione\r\n                maxRetries: 3,\r\n                id: `translate_${Date.now()}_${targetLanguage}`,\r\n            }\r\n        );\r\n        \r\n        return translatedText;\r\n    } catch (error) {\r\n        console.error('Errore traduzione con OpenAI:', error);\r\n        \r\n        // Se è un errore di rate limit, fornisci un messaggio più chiaro\r\n        if (error.message && (error.message.includes('rate') || error.message.includes('Limite') || error.message.includes('429'))) {\r\n            throw new Error('OpenAI ha raggiunto il limite di richieste. La richiesta è stata messa in coda e verrà riprovata automaticamente. Riprova tra qualche minuto.');\r\n        }\r\n        \r\n        throw new Error(`Errore durante la traduzione del testo: ${error.message || 'Errore sconosciuto'}`);\r\n    }\r\n}\r\n\r\n// Funzione per creare documento tradotto\r\nasync function createTranslatedDocument(originalText, translatedText, originalPath, originalFilename, targetLanguage) {\r\n    const ext = path.extname(originalFilename).toLowerCase();\r\n    \r\n    if (ext === '.pdf') {\r\n        // Per PDF, creiamo un nuovo PDF con il testo tradotto\r\n        // In produzione, useresti pdf-lib per mantenere meglio la formattazione\r\n        const doc = new PDFDocument();\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.pdf`);\r\n        const stream = fs.createWriteStream(outputPath);\r\n        doc.pipe(stream);\r\n        doc.fontSize(12);\r\n        \r\n        // Dividi il testo in paragrafi per una migliore formattazione\r\n        const paragraphs = translatedText.split('\\n\\n');\r\n        paragraphs.forEach((para, index) => {\r\n            if (index > 0) doc.moveDown();\r\n            doc.text(para, { align: 'left', continued: false });\r\n        });\r\n        \r\n        doc.end();\r\n        \r\n        await new Promise((resolve, reject) => {\r\n            stream.on('finish', resolve);\r\n            stream.on('error', reject);\r\n        });\r\n        \r\n        return fs.readFileSync(outputPath);\r\n    } else if (ext === '.docx') {\r\n        // Per DOCX, creiamo un nuovo documento\r\n        // In produzione, useresti docx o officegen per mantenere la formattazione\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}.txt`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    } else {\r\n        // Per TXT e MD, creiamo un nuovo file di testo\r\n        const outputPath = path.join(path.dirname(originalPath), `translated_${Date.now()}${ext}`);\r\n        fs.writeFileSync(outputPath, translatedText, 'utf-8');\r\n        return fs.readFileSync(outputPath);\r\n    }\r\n}\r\n\r\nexport default async function handler(req, res) {\r\n    // Handle CORS preflight\r\n    if (req.method === 'OPTIONS') {\r\n        res.setHeader('Access-Control-Allow-Origin', '*');\r\n        res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\r\n        res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n        res.status(200).end();\r\n        return;\r\n    }\r\n    \r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    // Su Vercel, usa /tmp (unico filesystem scrivibile)\r\n    const tmpDir = process.env.VERCEL ? '/tmp' : os.tmpdir();\r\n    const uploadDir = process.env.VERCEL ? '/tmp' : path.join(process.cwd(), 'uploads');\r\n    \r\n    // Su Vercel, /tmp esiste sempre, non serve crearlo\r\n    if (!process.env.VERCEL && !fs.existsSync(uploadDir)) {\r\n        fs.mkdirSync(uploadDir, { recursive: true });\r\n    }\r\n\r\n    const form = formidable({\r\n        uploadDir,\r\n        keepExtensions: true,\r\n        maxFileSize: 50 * 1024 * 1024, // 50MB\r\n    });\r\n\r\n    try {\r\n        const [fields, files] = await new Promise((resolve, reject) => {\r\n            form.parse(req, (err, fields, files) => {\r\n                if (err) reject(err);\r\n                else resolve([fields, files]);\r\n            });\r\n        });\r\n\r\n        const documentFile = Array.isArray(files.document) ? files.document[0] : files.document;\r\n        const targetLanguage = Array.isArray(fields.targetLanguage) ? fields.targetLanguage[0] : fields.targetLanguage || 'en';\r\n        const preserveFormatting = Array.isArray(fields.preserveFormatting) \r\n            ? fields.preserveFormatting[0] === 'true' \r\n            : fields.preserveFormatting === 'true';\r\n\r\n        if (!documentFile) {\r\n            return res.status(400).json({ error: 'Nessun documento caricato' });\r\n        }\r\n\r\n        // Verifica limiti d'uso (tool PRO)\r\n        const userId = getUserId(req);\r\n        const userPlan = getUserPlan(req);\r\n        const toolSlug = 'traduzione-documenti-ai';\r\n        const usageStats = getUsageStats(userId, toolSlug);\r\n        const fileInfo = {\r\n            size: documentFile.size,\r\n            length: 0, // Verrà aggiornato dopo l'estrazione del testo\r\n        };\r\n\r\n        const limitCheck = canUseTool(toolSlug, userPlan, usageStats, fileInfo);\r\n        \r\n        if (!limitCheck.allowed) {\r\n            return res.status(403).json({\r\n                error: limitCheck.reason,\r\n                limitType: limitCheck.limitType,\r\n                current: limitCheck.current,\r\n                max: limitCheck.max,\r\n                upgradeMessage: getUpgradeMessage(toolSlug, userPlan),\r\n                requiresPro: true,\r\n            });\r\n        }\r\n\r\n        // Estrai testo dal documento\r\n        const originalText = await extractText(\r\n            documentFile.filepath,\r\n            documentFile.mimetype,\r\n            documentFile.originalFilename\r\n        );\r\n\r\n        if (!originalText || originalText.trim().length === 0) {\r\n            return res.status(400).json({ error: 'Impossibile estrarre testo dal documento' });\r\n        }\r\n\r\n        // Verifica limite lunghezza testo\r\n        fileInfo.length = originalText.length;\r\n        const lengthCheck = canUseTool(toolSlug, userPlan, usageStats, fileInfo);\r\n        \r\n        if (!lengthCheck.allowed) {\r\n            return res.status(403).json({\r\n                error: lengthCheck.reason,\r\n                limitType: lengthCheck.limitType,\r\n                current: lengthCheck.current,\r\n                max: lengthCheck.max,\r\n                upgradeMessage: getUpgradeMessage(toolSlug, userPlan),\r\n                requiresPro: true,\r\n            });\r\n        }\r\n\r\n        // Traduci il testo\r\n        const translatedText = await translateText(originalText, targetLanguage, preserveFormatting);\r\n\r\n        // Crea documento tradotto\r\n        const translatedBuffer = await createTranslatedDocument(\r\n            originalText,\r\n            translatedText,\r\n            documentFile.filepath,\r\n            documentFile.originalFilename,\r\n            targetLanguage\r\n        );\r\n\r\n        // Determina il tipo MIME e nome file\r\n        const ext = path.extname(documentFile.originalFilename).toLowerCase();\r\n        let mimeType = 'application/octet-stream';\r\n        let filename = `translated_${targetLanguage}_${documentFile.originalFilename}`;\r\n\r\n        if (ext === '.pdf') {\r\n            mimeType = 'application/pdf';\r\n        } else if (ext === '.docx') {\r\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\r\n        } else if (ext === '.txt') {\r\n            mimeType = 'text/plain';\r\n        } else if (ext === '.md') {\r\n            mimeType = 'text/markdown';\r\n        }\r\n\r\n        // Cleanup\r\n        try {\r\n            fs.unlinkSync(documentFile.filepath);\r\n            // Pulisci anche i file temporanei creati\r\n            // Su Vercel, pulisci solo file temporanei nella stessa sessione\r\n            const tempFiles = process.env.VERCEL \r\n              ? [] // Su Vercel non puliamo altri file in /tmp\r\n              : fs.existsSync(uploadDir) ? fs.readdirSync(uploadDir).filter(f => f.startsWith('translated_')) : [];\r\n            tempFiles.forEach(f => {\r\n                try {\r\n                    fs.unlinkSync(path.join(uploadDir, f));\r\n                } catch (e) {}\r\n            });\r\n        } catch (e) {\r\n            console.error('Errore cleanup:', e);\r\n        }\r\n\r\n        // Incrementa contatore uso (solo se la richiesta è andata a buon fine)\r\n        incrementUsage(userId, toolSlug);\r\n\r\n        res.setHeader('Content-Type', mimeType);\r\n        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);\r\n        res.status(200).send(translatedBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Traduzione Documenti:', error);\r\n        console.error('Stack trace:', error.stack);\r\n        console.error('Error details:', {\r\n            message: error.message,\r\n            name: error.name,\r\n            code: error.code\r\n        });\r\n        \r\n        // Determina il messaggio di errore appropriato\r\n        let errorMessage = 'Errore durante la traduzione del documento. Riprova con un file diverso.';\r\n        \r\n        if (error.message) {\r\n            errorMessage = error.message;\r\n        } else if (error.code === 'ENOENT') {\r\n            errorMessage = 'File non trovato. Assicurati di aver caricato un file valido.';\r\n        } else if (error.code === 'LIMIT_FILE_SIZE') {\r\n            errorMessage = 'File troppo grande. Dimensione massima: 50MB.';\r\n        }\r\n        \r\n        res.status(500).json({ \r\n            error: errorMessage,\r\n            details: process.env.NODE_ENV === 'development' ? error.stack : undefined\r\n        });\r\n    }\r\n}\r\n","import type { NextApiResponse } from '../../types'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport { sendError } from '../../server/api-utils'\nimport { RouteKind } from '../../server/route-kind'\nimport type { Span } from '../../server/lib/trace/tracer'\nimport { PagesAPIRouteModule } from '../../server/route-modules/pages-api/module.compiled'\n\nimport { hoist } from './helpers'\n\n// Import the userland code.\nimport * as userland from 'VAR_USERLAND'\nimport { getTracer, SpanKind } from '../../server/lib/trace/tracer'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport type { InstrumentationOnRequestError } from '../../server/instrumentation/types'\nimport { addRequestMeta } from '../../server/request-meta'\n\n// Re-export the handler (should be the default export).\nexport default hoist(userland, 'default')\n\n// Re-export config.\nexport const config = hoist(userland, 'config')\n\n// Create and export the route module that will be consumed.\nconst routeModule = new PagesAPIRouteModule({\n  definition: {\n    kind: RouteKind.PAGES_API,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n  },\n  userland,\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil?: (prom: Promise<void>) => void\n  }\n): Promise<void> {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  }\n\n  const prepareResult = await routeModule.prepare(req, res, { srcPage })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return\n  }\n\n  const { query, params, prerenderManifest, routerServerContext } =\n    prepareResult\n\n  try {\n    const method = req.method || 'GET'\n    const tracer = getTracer()\n\n    const activeSpan = tracer.getActiveScopeSpan()\n    const onRequestError =\n      routeModule.instrumentationOnRequestError.bind(routeModule)\n\n    const invokeRouteModule = async (span?: Span) =>\n      routeModule\n        .render(req, res, {\n          query: {\n            ...query,\n            ...params,\n          },\n          params,\n          allowedRevalidateHeaderKeys: process.env\n            .__NEXT_ALLOWED_REVALIDATE_HEADERS as any as string[],\n          multiZoneDraftMode: Boolean(process.env.__NEXT_MULTI_ZONE_DRAFT_MODE),\n          trustHostHeader: process.env\n            .__NEXT_TRUST_HOST_HEADER as any as boolean,\n          // TODO: get this from from runtime env so manifest\n          // doesn't need to load\n          previewProps: prerenderManifest.preview,\n          propagateError: false,\n          dev: routeModule.isDev,\n          page: 'VAR_DEFINITION_PAGE',\n\n          internalRevalidate: routerServerContext?.revalidate,\n\n          onError: (...args: Parameters<InstrumentationOnRequestError>) =>\n            onRequestError(req, ...args),\n        })\n        .finally(() => {\n          if (!span) return\n\n          span.setAttributes({\n            'http.status_code': res.statusCode,\n            'next.rsc': false,\n          })\n\n          const rootSpanAttributes = tracer.getRootSpanAttributes()\n          // We were unable to get attributes, probably OTEL is not enabled\n          if (!rootSpanAttributes) {\n            return\n          }\n\n          if (\n            rootSpanAttributes.get('next.span_type') !==\n            BaseServerSpan.handleRequest\n          ) {\n            console.warn(\n              `Unexpected root span type '${rootSpanAttributes.get(\n                'next.span_type'\n              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n            )\n            return\n          }\n\n          const route = rootSpanAttributes.get('next.route')\n          if (route) {\n            const name = `${method} ${route}`\n\n            span.setAttributes({\n              'next.route': route,\n              'http.route': route,\n              'next.span_name': name,\n            })\n            span.updateName(name)\n          } else {\n            span.updateName(`${method} ${srcPage}`)\n          }\n        })\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await invokeRouteModule(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          invokeRouteModule\n        )\n      )\n    }\n  } catch (err) {\n    // we re-throw in dev to show the error overlay\n    if (routeModule.isDev) {\n      throw err\n    }\n    // this is technically an invariant as error handling\n    // should be done inside of api-resolver onError\n    sendError(res as NextApiResponse, 500, 'Internal Server Error')\n  } finally {\n    // We don't allow any waitUntil work in pages API routes currently\n    // so if callback is present return with resolved promise since no\n    // pending work\n    ctx.waitUntil?.(Promise.resolve())\n  }\n}\n"],"names":["sendError","RouteKind","PagesAPIRouteModule","hoist","userland","getTracer","SpanKind","BaseServerSpan","addRequestMeta","config","routeModule","definition","kind","PAGES_API","page","pathname","bundlePath","filename","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","query","params","prerenderManifest","routerServerContext","method","tracer","activeSpan","getActiveScopeSpan","onRequestError","instrumentationOnRequestError","bind","invokeRouteModule","span","render","allowedRevalidateHeaderKeys","__NEXT_ALLOWED_REVALIDATE_HEADERS","multiZoneDraftMode","Boolean","__NEXT_MULTI_ZONE_DRAFT_MODE","trustHostHeader","__NEXT_TRUST_HOST_HEADER","previewProps","preview","propagateError","dev","internalRevalidate","revalidate","onError","args","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","withPropagatedContext","headers","trace","spanName","SERVER","attributes","url","err"],"mappings":"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","ignoreList":[2]}