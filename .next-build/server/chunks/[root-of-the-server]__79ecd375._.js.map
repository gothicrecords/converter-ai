{"version":3,"sources":["../../../utils/advancedUpscaler.js","../../../utils/proceduralImageGenerator.js","../../../node_modules/next/dist/esm/build/templates/pages-api.js","../../../pages/api/tools/generate-image.js"],"sourcesContent":["import sharp from 'sharp';\r\n\r\n/**\r\n * Upscaler avanzato per immagini 4K/8K\r\n * Usa tecniche multi-pass, denoising e sharpening avanzato\r\n */\r\nclass AdvancedUpscaler {\r\n    constructor() {\r\n        this.maxDimension = 7680; // 8K\r\n    }\r\n\r\n    // Denoising avanzato prima dell'upscaling\r\n    async denoise(image) {\r\n        // Applica leggero blur per ridurre noise, poi sharpening mirato\r\n        return image\r\n            .blur(0.3) // Leggero blur per noise\r\n            .sharpen({\r\n                sigma: 0.5,\r\n                m1: 0.4,\r\n                m2: 0.2\r\n            });\r\n    }\r\n\r\n    // Upscaling multi-pass per qualità massima\r\n    async multiPassUpscale(image, targetWidth, targetHeight, passes = 3) {\r\n        const metadata = await image.metadata();\r\n        let currentWidth = metadata.width;\r\n        let currentHeight = metadata.height;\r\n        \r\n        let currentImage = image;\r\n        \r\n        // Calcola fattore di scala per passaggio\r\n        const totalScale = Math.max(\r\n            targetWidth / currentWidth,\r\n            targetHeight / currentHeight\r\n        );\r\n        const scalePerPass = Math.pow(totalScale, 1 / passes);\r\n        \r\n        for (let pass = 0; pass < passes; pass++) {\r\n            const nextWidth = Math.min(\r\n                Math.round(currentWidth * scalePerPass),\r\n                targetWidth\r\n            );\r\n            const nextHeight = Math.min(\r\n                Math.round(currentHeight * scalePerPass),\r\n                targetHeight\r\n            );\r\n            \r\n            // Usa kernel diverso per ogni passaggio\r\n            let kernel = sharp.kernel.lanczos3;\r\n            if (pass === 0) {\r\n                kernel = sharp.kernel.lanczos3; // Primo passaggio: massima qualità\r\n            } else if (pass === passes - 1) {\r\n                kernel = sharp.kernel.lanczos3; // Ultimo passaggio: massima qualità\r\n            } else {\r\n                kernel = sharp.kernel.lanczos2; // Passaggi intermedi: bilanciato\r\n            }\r\n            \r\n            // Resize con kernel ottimizzato\r\n            currentImage = currentImage.resize(nextWidth, nextHeight, {\r\n                kernel,\r\n                fit: 'fill',\r\n                withoutEnlargement: false\r\n            });\r\n            \r\n            // Sharpening progressivo (più aggressivo negli ultimi passaggi)\r\n            const sharpenIntensity = 0.3 + (pass / passes) * 0.4;\r\n            currentImage = currentImage.sharpen({\r\n                sigma: 0.4 + sharpenIntensity,\r\n                m1: 0.3 + (pass / passes) * 0.2,\r\n                m2: 0.15 + (pass / passes) * 0.15\r\n            });\r\n            \r\n            // Converti a buffer per il prossimo passaggio\r\n            if (pass < passes - 1) {\r\n                const buffer = await currentImage.toBuffer();\r\n                currentImage = sharp(buffer, { sequentialRead: true });\r\n            }\r\n            \r\n            currentWidth = nextWidth;\r\n            currentHeight = nextHeight;\r\n        }\r\n        \r\n        return currentImage;\r\n    }\r\n\r\n    // Applica enhancement finale\r\n    async applyFinalEnhancement(image, quality = 'high') {\r\n        let enhanced = image;\r\n        \r\n        // Contrasto leggero per chiarezza\r\n        enhanced = enhanced.linear(1.02, -(128 * 0.02));\r\n        \r\n        // Sharpening finale mirato\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 1.2,\r\n            m1: 0.7,\r\n            m2: 0.4\r\n        });\r\n        \r\n        // Rimozione artefatti\r\n        enhanced = enhanced.png({\r\n            quality: 100,\r\n            compressionLevel: 6,\r\n            adaptiveFiltering: true\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    // Upscale principale con pipeline completa\r\n    async upscale(buffer, targetScale = 4, maxDimension = 7680) {\r\n        try {\r\n            const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n            const metadata = await input.metadata();\r\n            \r\n            const originalWidth = metadata.width || 0;\r\n            const originalHeight = metadata.height || 0;\r\n            \r\n            if (originalWidth === 0 || originalHeight === 0) {\r\n                throw new Error('Dimensioni immagine non valide');\r\n            }\r\n            \r\n            // Calcola dimensioni target\r\n            let targetWidth = Math.round(originalWidth * targetScale);\r\n            let targetHeight = Math.round(originalHeight * targetScale);\r\n            \r\n            // Limita a maxDimension\r\n            if (targetWidth > maxDimension || targetHeight > maxDimension) {\r\n                const scale = maxDimension / Math.max(targetWidth, targetHeight);\r\n                targetWidth = Math.round(targetWidth * scale);\r\n                targetHeight = Math.round(targetHeight * scale);\r\n            }\r\n            \r\n            console.log(`Upscaling: ${originalWidth}x${originalHeight} -> ${targetWidth}x${targetHeight}`);\r\n            \r\n            // Step 1: Denoising (solo se immagine piccola o con noise evidente)\r\n            let processed = input;\r\n            const mp = (originalWidth * originalHeight) / 1e6;\r\n            if (mp < 2) {\r\n                processed = await this.denoise(processed);\r\n            }\r\n            \r\n            // Step 2: Multi-pass upscaling\r\n            const scaleFactor = Math.max(\r\n                targetWidth / originalWidth,\r\n                targetHeight / originalHeight\r\n            );\r\n            \r\n            // Determina numero di passaggi basato su scala\r\n            let passes = 2;\r\n            if (scaleFactor > 3) {\r\n                passes = 4;\r\n            } else if (scaleFactor > 2) {\r\n                passes = 3;\r\n            }\r\n            \r\n            processed = await this.multiPassUpscale(\r\n                processed,\r\n                targetWidth,\r\n                targetHeight,\r\n                passes\r\n            );\r\n            \r\n            // Step 3: Enhancement finale\r\n            processed = await this.applyFinalEnhancement(processed, 'high');\r\n            \r\n            // Converti a JPEG per output finale (migliore compressione)\r\n            const outputBuffer = await processed\r\n                .jpeg({\r\n                    quality: 98,\r\n                    chromaSubsampling: '4:4:4',\r\n                    mozjpeg: true,\r\n                    trellisQuantisation: true,\r\n                    overshootDeringing: true,\r\n                    optimiseScans: true\r\n                })\r\n                .toBuffer();\r\n            \r\n            console.log(`Upscale completato: ${(outputBuffer.length / 1024 / 1024).toFixed(2)} MB`);\r\n            \r\n            return outputBuffer;\r\n            \r\n        } catch (error) {\r\n            console.error('Errore upscaling avanzato:', error);\r\n            throw new Error(`Upscaling fallito: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    // Upscale a 4K (3840x2160 o lato lungo 3840)\r\n    async upscaleTo4K(buffer) {\r\n        const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n        const metadata = await input.metadata();\r\n        \r\n        const originalWidth = metadata.width || 0;\r\n        const originalHeight = metadata.height || 0;\r\n        \r\n        // Calcola dimensioni 4K mantenendo aspect ratio\r\n        const longSide = Math.max(originalWidth, originalHeight);\r\n        const scale = 3840 / longSide;\r\n        \r\n        const targetWidth = Math.round(originalWidth * scale);\r\n        const targetHeight = Math.round(originalHeight * scale);\r\n        \r\n        return this.upscale(buffer, scale, 3840);\r\n    }\r\n\r\n    // Upscale a 8K (7680x4320 o lato lungo 7680)\r\n    async upscaleTo8K(buffer) {\r\n        const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n        const metadata = await input.metadata();\r\n        \r\n        const originalWidth = metadata.width || 0;\r\n        const originalHeight = metadata.height || 0;\r\n        \r\n        // Calcola dimensioni 8K mantenendo aspect ratio\r\n        const longSide = Math.max(originalWidth, originalHeight);\r\n        const scale = 7680 / longSide;\r\n        \r\n        const targetWidth = Math.round(originalWidth * scale);\r\n        const targetHeight = Math.round(originalHeight * scale);\r\n        \r\n        return this.upscale(buffer, scale, 7680);\r\n    }\r\n}\r\n\r\nexport default AdvancedUpscaler;\r\n\r\n","import sharp from 'sharp';\r\n\r\n/**\r\n * Generatore di immagini procedurali avanzato completamente locale\r\n * Crea immagini uniche basate su prompt usando tecniche procedurali avanzate\r\n */\r\nclass ProceduralImageGenerator {\r\n    constructor() {\r\n        this.seed = null;\r\n    }\r\n\r\n    // Genera seed deterministica dal prompt\r\n    hashString(str) {\r\n        let hash = 0;\r\n        for (let i = 0; i < str.length; i++) {\r\n            const char = str.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash = hash & hash; // Convert to 32bit integer\r\n        }\r\n        return Math.abs(hash);\r\n    }\r\n\r\n    // Genera numero pseudo-random basato su seed\r\n    random(seed) {\r\n        const x = Math.sin(seed) * 10000;\r\n        return x - Math.floor(x);\r\n    }\r\n\r\n    // Estrae keyword dal prompt per determinare lo stile\r\n    extractKeywords(prompt) {\r\n        const lower = prompt.toLowerCase();\r\n        const keywords = {\r\n            colors: [],\r\n            style: 'abstract',\r\n            theme: 'nature',\r\n            mood: 'calm'\r\n        };\r\n\r\n        // Colori\r\n        const colorMap = {\r\n            'rosso': [255, 0, 0], 'red': [255, 0, 0],\r\n            'blu': [0, 0, 255], 'blue': [0, 0, 255],\r\n            'verde': [0, 255, 0], 'green': [0, 255, 0],\r\n            'giallo': [255, 255, 0], 'yellow': [255, 255, 0],\r\n            'viola': [128, 0, 128], 'purple': [128, 0, 128],\r\n            'arancione': [255, 165, 0], 'orange': [255, 165, 0],\r\n            'rosa': [255, 192, 203], 'pink': [255, 192, 203],\r\n            'nero': [0, 0, 0], 'black': [0, 0, 0],\r\n            'bianco': [255, 255, 255], 'white': [255, 255, 255],\r\n            'grigio': [128, 128, 128], 'gray': [128, 128, 128], 'grey': [128, 128, 128]\r\n        };\r\n\r\n        for (const [key, value] of Object.entries(colorMap)) {\r\n            if (lower.includes(key)) {\r\n                keywords.colors.push(value);\r\n            }\r\n        }\r\n\r\n        // Stile\r\n        if (lower.includes('realistic') || lower.includes('realistico') || lower.includes('foto')) {\r\n            keywords.style = 'realistic';\r\n        } else if (lower.includes('abstract') || lower.includes('astratto')) {\r\n            keywords.style = 'abstract';\r\n        } else if (lower.includes('artistic') || lower.includes('artistico')) {\r\n            keywords.style = 'artistic';\r\n        } else if (lower.includes('minimal') || lower.includes('minimalista')) {\r\n            keywords.style = 'minimal';\r\n        }\r\n\r\n        // Tema\r\n        if (lower.includes('natura') || lower.includes('nature') || lower.includes('paesaggio') || lower.includes('landscape')) {\r\n            keywords.theme = 'nature';\r\n        } else if (lower.includes('città') || lower.includes('city') || lower.includes('urban')) {\r\n            keywords.theme = 'urban';\r\n        } else if (lower.includes('spazio') || lower.includes('space') || lower.includes('cosmo')) {\r\n            keywords.theme = 'space';\r\n        } else if (lower.includes('oceano') || lower.includes('ocean') || lower.includes('mare') || lower.includes('sea')) {\r\n            keywords.theme = 'ocean';\r\n        }\r\n\r\n        // Mood\r\n        if (lower.includes('calm') || lower.includes('calmo') || lower.includes('sereno')) {\r\n            keywords.mood = 'calm';\r\n        } else if (lower.includes('energetic') || lower.includes('energico') || lower.includes('vibrante')) {\r\n            keywords.mood = 'energetic';\r\n        } else if (lower.includes('dark') || lower.includes('scuro') || lower.includes('oscuro')) {\r\n            keywords.mood = 'dark';\r\n        }\r\n\r\n        return keywords;\r\n    }\r\n\r\n    // Noise Perlin-like semplificato\r\n    noise2D(x, y, seed) {\r\n        const n = Math.floor(x) + Math.floor(y) * 57;\r\n        const n2 = (n << 13) ^ n;\r\n        const seedValue = (seed + n2) * 9301 + 49297;\r\n        return ((seedValue & 0x7fffffff) / 2147483648.0) * 2.0 - 1.0;\r\n    }\r\n\r\n    // Interpolazione smooth\r\n    smoothstep(edge0, edge1, x) {\r\n        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));\r\n        return t * t * (3 - 2 * t);\r\n    }\r\n\r\n    // Crea gradiente complesso con tecniche avanzate\r\n    async createComplexGradient(width, height, colors, seed) {\r\n        const channels = 3;\r\n        const buffer = Buffer.alloc(width * height * channels);\r\n        \r\n        // Genera multiple layer di pattern\r\n        const layers = 3;\r\n        \r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const idx = (y * width + x) * channels;\r\n                \r\n                // Calcola posizione normalizzata\r\n                const nx = x / width;\r\n                const ny = y / height;\r\n                \r\n                // Distanza dal centro (multiple centri per pattern complesso)\r\n                const dx = nx - 0.5;\r\n                const dy = ny - 0.5;\r\n                const dist = Math.sqrt(dx * dx + dy * dy);\r\n                \r\n                // Angolo\r\n                const angle = Math.atan2(dy, dx);\r\n                \r\n                // Seleziona colore base\r\n                let color = [128, 128, 128];\r\n                if (colors.length > 0) {\r\n                    // Mix di colori basato su pattern complesso\r\n                    const colorMix = [];\r\n                    for (let i = 0; i < colors.length; i++) {\r\n                        const weight = Math.abs(Math.sin(angle * (i + 1) + dist * 5));\r\n                        colorMix.push(weight);\r\n                    }\r\n                    \r\n                    // Normalizza pesi\r\n                    const totalWeight = colorMix.reduce((a, b) => a + b, 0) || 1;\r\n                    const r = colorMix.reduce((sum, w, i) => sum + (colors[i][0] * w), 0) / totalWeight;\r\n                    const g = colorMix.reduce((sum, w, i) => sum + (colors[i][1] * w), 0) / totalWeight;\r\n                    const b = colorMix.reduce((sum, w, i) => sum + (colors[i][2] * w), 0) / totalWeight;\r\n                    color = [r, g, b];\r\n                } else {\r\n                    // Colori procedurali avanzati\r\n                    const hue = (angle / Math.PI + 1) * 0.5;\r\n                    const saturation = 0.5 + dist * 0.5;\r\n                    const lightness = 0.3 + (1 - dist * 1.5) * 0.4;\r\n                    color = this.hslToRgb(hue * 360, saturation * 100, lightness * 100);\r\n                }\r\n                \r\n                // Aggiungi pattern multi-layer\r\n                let finalR = color[0];\r\n                let finalG = color[1];\r\n                let finalB = color[2];\r\n                \r\n                for (let layer = 0; layer < layers; layer++) {\r\n                    const layerSeed = seed + layer * 10000;\r\n                    const freq = Math.pow(2, layer);\r\n                    const amplitude = 1.0 / (layer + 1);\r\n                    \r\n                    // Noise procedurale\r\n                    const noiseX = nx * freq * 10;\r\n                    const noiseY = ny * freq * 10;\r\n                    const noise = this.noise2D(noiseX, noiseY, layerSeed);\r\n                    \r\n                    // Pattern radiali\r\n                    const radial = Math.sin(dist * freq * Math.PI * 4) * amplitude;\r\n                    \r\n                    // Pattern angolari\r\n                    const angular = Math.sin(angle * freq * 3) * amplitude * 0.5;\r\n                    \r\n                    // Combina pattern\r\n                    const pattern = (noise + radial + angular) * 30;\r\n                    \r\n                    finalR += pattern;\r\n                    finalG += pattern * 0.9;\r\n                    finalB += pattern * 0.8;\r\n                }\r\n                \r\n                // Clamp valori\r\n                buffer[idx] = Math.max(0, Math.min(255, finalR));\r\n                buffer[idx + 1] = Math.max(0, Math.min(255, finalG));\r\n                buffer[idx + 2] = Math.max(0, Math.min(255, finalB));\r\n            }\r\n        }\r\n        \r\n        return sharp(buffer, {\r\n            raw: {\r\n                width,\r\n                height,\r\n                channels: 3\r\n            }\r\n        });\r\n    }\r\n\r\n    // Aggiunge pattern e texture\r\n    async addPatterns(image, keywords, seed) {\r\n        const { width, height } = await image.metadata();\r\n        \r\n        // Crea pattern overlay\r\n        const patternBuffer = Buffer.alloc(width * height * 4);\r\n        \r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const idx = (y * width + x) * 4;\r\n                \r\n                let pattern = 0;\r\n                \r\n                // Pattern basati su tema\r\n                if (keywords.theme === 'nature') {\r\n                    // Pattern organici\r\n                    const fx = x / 50;\r\n                    const fy = y / 50;\r\n                    pattern = Math.sin(fx * Math.PI) * Math.cos(fy * Math.PI) * 0.1;\r\n                } else if (keywords.theme === 'space') {\r\n                    // Pattern stellari\r\n                    const fx = x / 20;\r\n                    const fy = y / 20;\r\n                    pattern = (Math.sin(fx) * Math.sin(fy) > 0.8) ? 0.2 : 0;\r\n                } else if (keywords.theme === 'ocean') {\r\n                    // Pattern ondulati\r\n                    const fx = x / 30;\r\n                    const fy = y / 30;\r\n                    pattern = Math.sin(fx + fy) * 0.15;\r\n                } else {\r\n                    // Pattern astratti\r\n                    const fx = x / 40;\r\n                    const fy = y / 40;\r\n                    pattern = (Math.sin(fx) + Math.cos(fy)) * 0.1;\r\n                }\r\n                \r\n                // Aggiungi noise procedurale\r\n                const noise = (this.random(seed + x + y) - 0.5) * 0.05;\r\n                pattern += noise;\r\n                \r\n                patternBuffer[idx] = 255; // R\r\n                patternBuffer[idx + 1] = 255; // G\r\n                patternBuffer[idx + 2] = 255; // B\r\n                patternBuffer[idx + 3] = Math.floor((pattern + 0.5) * 50); // Alpha\r\n            }\r\n        }\r\n        \r\n        const patternImage = sharp(patternBuffer, {\r\n            raw: {\r\n                width,\r\n                height,\r\n                channels: 4\r\n            }\r\n        });\r\n        \r\n        return image.composite([{\r\n            input: await patternImage.toBuffer(),\r\n            blend: 'overlay'\r\n        }]);\r\n    }\r\n\r\n    // Applica effetti avanzati\r\n    async applyAdvancedEffects(image, keywords, detail) {\r\n        let processed = image;\r\n        \r\n        // Sharpening basato su dettaglio (più aggressivo)\r\n        const sharpenSigma = 0.8 + (detail * 0.7);\r\n        processed = processed.sharpen({\r\n            sigma: sharpenSigma,\r\n            m1: 0.6 + (detail * 0.3),\r\n            m2: 0.3 + (detail * 0.2)\r\n        });\r\n        \r\n        // Contrasto e saturazione basati su mood\r\n        if (keywords.mood === 'energetic') {\r\n            processed = processed\r\n                .modulate({\r\n                    brightness: 1.15,\r\n                    saturation: 1.4,\r\n                    hue: 0\r\n                })\r\n                .linear(1.1, -(128 * 0.1)); // Contrasto aggiuntivo\r\n        } else if (keywords.mood === 'calm') {\r\n            processed = processed\r\n                .modulate({\r\n                    brightness: 0.98,\r\n                    saturation: 0.85,\r\n                    hue: 0\r\n                })\r\n                .linear(0.98, 0); // Contrasto ridotto\r\n        } else if (keywords.mood === 'dark') {\r\n            processed = processed\r\n                .modulate({\r\n                    brightness: 0.65,\r\n                    saturation: 1.2,\r\n                    hue: 0\r\n                })\r\n                .linear(1.15, -(128 * 0.15)); // Contrasto aumentato\r\n        } else {\r\n            // Default: miglioramento generale\r\n            processed = processed\r\n                .modulate({\r\n                    brightness: 1.02,\r\n                    saturation: 1.1,\r\n                    hue: 0\r\n                })\r\n                .linear(1.05, -(128 * 0.05));\r\n        }\r\n        \r\n        // Vignette e gamma per stile realistico\r\n        if (keywords.style === 'realistic') {\r\n            processed = processed\r\n                .gamma(1.15)\r\n                .linear(1.08, -(128 * 0.08));\r\n        } else if (keywords.style === 'artistic') {\r\n            processed = processed\r\n                .gamma(0.95)\r\n                .modulate({\r\n                    brightness: 1.05,\r\n                    saturation: 1.25,\r\n                    hue: 0\r\n                });\r\n        }\r\n        \r\n        // Denoising leggero per immagini procedurali\r\n        processed = processed.blur(0.2);\r\n        \r\n        // Sharpening finale per dettagli\r\n        processed = processed.sharpen({\r\n            sigma: 0.5 + (detail * 0.3),\r\n            m1: 0.4,\r\n            m2: 0.2\r\n        });\r\n        \r\n        return processed;\r\n    }\r\n\r\n    // Genera immagine principale\r\n    async generate(prompt, width, height, detail = 1.0, realism = true) {\r\n        // Genera seed dal prompt\r\n        this.seed = this.hashString(prompt);\r\n        \r\n        // Estrai keyword\r\n        const keywords = this.extractKeywords(prompt);\r\n        \r\n        // Determina colori\r\n        let colors = keywords.colors;\r\n        if (colors.length === 0) {\r\n            // Colori di default basati su seed\r\n            const baseHue = this.random(this.seed) * 360;\r\n            colors = [\r\n                this.hslToRgb(baseHue, 70, 50),\r\n                this.hslToRgb((baseHue + 60) % 360, 70, 60),\r\n                this.hslToRgb((baseHue + 120) % 360, 70, 40)\r\n            ];\r\n        }\r\n        \r\n        // Crea gradiente base\r\n        let image = await this.createComplexGradient(width, height, colors, this.seed);\r\n        \r\n        // Aggiungi pattern\r\n        image = await this.addPatterns(image, keywords, this.seed);\r\n        \r\n        // Applica effetti avanzati\r\n        image = await this.applyAdvancedEffects(image, keywords, detail);\r\n        \r\n        // Converti a buffer\r\n        return await image.jpeg({\r\n            quality: 95,\r\n            chromaSubsampling: '4:4:4',\r\n            mozjpeg: true\r\n        }).toBuffer();\r\n    }\r\n\r\n    // Converte HSL a RGB\r\n    hslToRgb(h, s, l) {\r\n        h /= 360;\r\n        s /= 100;\r\n        l /= 100;\r\n        \r\n        let r, g, b;\r\n        \r\n        if (s === 0) {\r\n            r = g = b = l;\r\n        } else {\r\n            const hue2rgb = (p, q, t) => {\r\n                if (t < 0) t += 1;\r\n                if (t > 1) t -= 1;\r\n                if (t < 1/6) return p + (q - p) * 6 * t;\r\n                if (t < 1/2) return q;\r\n                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n                return p;\r\n            };\r\n            \r\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n            const p = 2 * l - q;\r\n            r = hue2rgb(p, q, h + 1/3);\r\n            g = hue2rgb(p, q, h);\r\n            b = hue2rgb(p, q, h - 1/3);\r\n        }\r\n        \r\n        return [\r\n            Math.round(r * 255),\r\n            Math.round(g * 255),\r\n            Math.round(b * 255)\r\n        ];\r\n    }\r\n}\r\n\r\nexport default ProceduralImageGenerator;\r\n\r\n","import { sendError } from \"next/dist/esm/server/api-utils\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { PagesAPIRouteModule } from \"next/dist/esm/server/route-modules/pages-api/module.compiled\";\nimport { hoist } from \"next/dist/esm/build/templates/helpers\";\n// Import the userland code.\nimport * as userland from \"INNER_PAGE\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { addRequestMeta } from \"next/dist/esm/server/request-meta\";\n// Re-export the handler (should be the default export).\nexport default hoist(userland, 'default');\n// Re-export config.\nexport const config = hoist(userland, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new PagesAPIRouteModule({\n    definition: {\n        kind: RouteKind.PAGES_API,\n        page: \"/api/tools/generate-image\",\n        pathname: \"/api/tools/generate-image\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland,\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n});\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/tools/generate-image\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    }\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return;\n    }\n    const { query, params, prerenderManifest, routerServerContext } = prepareResult;\n    try {\n        const method = req.method || 'GET';\n        const tracer = getTracer();\n        const activeSpan = tracer.getActiveScopeSpan();\n        const onRequestError = routeModule.instrumentationOnRequestError.bind(routeModule);\n        const invokeRouteModule = async (span)=>routeModule.render(req, res, {\n                query: {\n                    ...query,\n                    ...params\n                },\n                params,\n                allowedRevalidateHeaderKeys: process.env.__NEXT_ALLOWED_REVALIDATE_HEADERS,\n                multiZoneDraftMode: Boolean(process.env.__NEXT_MULTI_ZONE_DRAFT_MODE),\n                trustHostHeader: process.env.__NEXT_TRUST_HOST_HEADER,\n                // TODO: get this from from runtime env so manifest\n                // doesn't need to load\n                previewProps: prerenderManifest.preview,\n                propagateError: false,\n                dev: routeModule.isDev,\n                page: \"/api/tools/generate-image\",\n                internalRevalidate: routerServerContext == null ? void 0 : routerServerContext.revalidate,\n                onError: (...args)=>onRequestError(req, ...args)\n            }).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await invokeRouteModule(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, invokeRouteModule));\n        }\n    } catch (err) {\n        // we re-throw in dev to show the error overlay\n        if (routeModule.isDev) {\n            throw err;\n        }\n        // this is technically an invariant as error handling\n        // should be done inside of api-resolver onError\n        sendError(res, 500, 'Internal Server Error');\n    } finally{\n        // We don't allow any waitUntil work in pages API routes currently\n        // so if callback is present return with resolved promise since no\n        // pending work\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n    }\n}\n\n//# sourceMappingURL=pages-api.js.map\n","import ProceduralImageGenerator from '../../../utils/proceduralImageGenerator';\r\nimport AdvancedUpscaler from '../../../utils/advancedUpscaler';\r\n\r\nexport default async function handler(req, res) {\r\n    if (req.method !== 'POST') {\r\n        return res.status(405).json({ error: 'Method not allowed' });\r\n    }\r\n\r\n    try {\r\n        const { prompt, aspect = '1:1', detail = 1.0, realism = true } = req.body || {};\r\n\r\n        if (!prompt || typeof prompt !== 'string') {\r\n            return res.status(400).json({ error: 'Il prompt è richiesto e deve essere una stringa.' });\r\n        }\r\n\r\n        // Dimensions - generiamo direttamente in alta risoluzione\r\n        const baseLong = 2048; // Base generation più alta per qualità migliore\r\n        const targetLong = 3840; // 4K target\r\n        const aspectMap = {\r\n            '1:1': [1, 1],\r\n            '16:9': [16, 9],\r\n            '9:16': [9, 16],\r\n            '4:3': [4, 3],\r\n            '3:4': [3, 4],\r\n        };\r\n        const ratio = aspectMap[aspect] || aspectMap['1:1'];\r\n        const rW = ratio[0];\r\n        const rH = ratio[1];\r\n        const baseW = Math.round((rW >= rH ? baseLong : (baseLong * rW) / rH));\r\n        const baseH = Math.round((rH > rW ? baseLong : (baseLong * rH) / rW));\r\n\r\n        console.log('Generating image procedurally (completely local):', prompt);\r\n        console.log('Base dimensions:', baseW, 'x', baseH);\r\n\r\n        // Genera immagine base usando generatore procedurale locale\r\n        const generator = new ProceduralImageGenerator();\r\n        const baseImageBuffer = await generator.generate(prompt, baseW, baseH, detail, realism);\r\n\r\n        console.log('Base image generated, size:', (baseImageBuffer.length / 1024 / 1024).toFixed(2), 'MB');\r\n\r\n        // Upscale a 4K usando upscaler avanzato\r\n        const upscaler = new AdvancedUpscaler();\r\n        const upscaledBuffer = await upscaler.upscaleTo4K(baseImageBuffer);\r\n\r\n        console.log('Final 4K output size:', (upscaledBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');\r\n\r\n        res.setHeader('Content-Type', 'image/jpeg');\r\n        res.setHeader('Content-Length', upscaledBuffer.byteLength);\r\n        res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\r\n        res.setHeader('Pragma', 'no-cache');\r\n        res.setHeader('Expires', '0');\r\n        res.status(200).send(upscaledBuffer);\r\n\r\n    } catch (error) {\r\n        console.error('Errore API Generate Image:', error);\r\n        res.status(500).json({ \r\n            error: error.message || 'Errore interno del server durante la generazione dell\\'immagine.' \r\n        });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[2]}