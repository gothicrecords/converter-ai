{"version":3,"sources":["../../../pages/api/convert/%5Btarget%5D.js","../../../node_modules/next/src/build/templates/pages-api.ts"],"sourcesContent":["import formidable from 'formidable';\nimport fs from 'fs';\nimport path from 'path';\nimport sharp from 'sharp';\nimport PDFDocument from 'pdfkit';\nimport JSZip from 'jszip';\nimport * as XLSX from 'xlsx';\nimport pdfParse from 'pdf-parse';\nimport htmlPdf from 'html-pdf-node';\nimport SVGtoPDF from 'svg-to-pdfkit';\nimport zlib from 'zlib';\nimport tarStream from 'tar-stream';\nimport ttf2woff from 'ttf2woff';\nimport ttf2woff2 from 'ttf2woff2';\nimport ffmpegStatic from 'ffmpeg-static';\nimport ffmpeg from 'fluent-ffmpeg';\nimport mammoth from 'mammoth';\nimport { marked } from 'marked';\nimport Epub from 'epub-gen';\nimport ttf2eotConv from 'ttf2eot';\nimport { path7za } from '7zip-bin';\nimport { execFile } from 'child_process';\nimport { createExtractorFromData } from 'node-unrar-js';\n// Le librerie docx e rtf-parser verranno importate dinamicamente quando necessarie\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nconst execAsync = promisify(exec);\nimport os from 'os';\nimport { \n  handleApiError, \n  ValidationError, \n  ProcessingError,\n  FileSystemError,\n  NotFoundError\n} from '../../../errors';\n\n// Helper per verificare se un comando è disponibile (cross-platform)\nasync function commandExists(command) {\n  const isWindows = process.platform === 'win32';\n  const checkCmd = isWindows ? `where ${command} 2>nul` : `which ${command}`;\n  try {\n    const { stdout } = await execAsync(checkCmd);\n    return stdout.trim().length > 0;\n  } catch {\n    return false;\n  }\n}\n\n// Helper per trovare soffice su Windows in percorsi comuni\nfunction findLibreOfficeWindows() {\n  const possiblePaths = [\n    process.env.PROGRAMFILES + '\\\\LibreOffice\\\\program\\\\soffice.exe',\n    process.env['PROGRAMFILES(X86)'] + '\\\\LibreOffice\\\\program\\\\soffice.exe',\n    'C:\\\\Program Files\\\\LibreOffice\\\\program\\\\soffice.exe',\n    'C:\\\\Program Files (x86)\\\\LibreOffice\\\\program\\\\soffice.exe',\n    process.env.LOCALAPPDATA + '\\\\Programs\\\\LibreOffice\\\\program\\\\soffice.exe'\n  ];\n  \n  for (const p of possiblePaths) {\n    if (p && fs.existsSync(p)) {\n      return p;\n    }\n  }\n  return null;\n}\n\n// Helper per convertire tramite LibreOffice (se disponibile)\nasync function convertViaLibreOffice(inputPath, outputDir, outputFormat) {\n  const isWindows = process.platform === 'win32';\n  let soffice = null;\n  \n  // Su Windows, LibreOffice può essere in percorsi comuni\n  if (isWindows) {\n    // Cerca in percorsi comuni\n    soffice = findLibreOfficeWindows();\n    \n    // Se non trovato, verifica nel PATH\n    if (!soffice) {\n      try {\n        if (await commandExists('soffice.exe')) {\n          soffice = 'soffice.exe';\n        }\n      } catch {}\n    }\n    \n    if (!soffice) {\n      console.warn('LibreOffice non trovato. Per installarlo: https://www.libreoffice.org/download/');\n      return null;\n    }\n  } else {\n    // Linux/Mac\n    try {\n      if (await commandExists('soffice')) {\n        soffice = 'soffice';\n      } else if (await commandExists('/usr/bin/soffice')) {\n        soffice = '/usr/bin/soffice';\n      } else if (await commandExists('/Applications/LibreOffice.app/Contents/MacOS/soffice')) {\n        soffice = '/Applications/LibreOffice.app/Contents/MacOS/soffice';\n      } else {\n        console.warn('LibreOffice non trovato. Installa LibreOffice per usare questa funzione.');\n        return null;\n      }\n    } catch {}\n    \n    if (!soffice) {\n      return null;\n    }\n  }\n  \n  try {\n    // LibreOffice comando: soffice --headless --convert-to <format> --outdir <dir> <file>\n    const cmd = isWindows \n      ? `\"${soffice}\" --headless --convert-to ${outputFormat} --outdir \"${outputDir}\" \"${inputPath}\"`\n      : `soffice --headless --convert-to ${outputFormat} --outdir \"${outputDir}\" \"${inputPath}\"`;\n    \n    await execAsync(cmd, { timeout: 60000 }); // 60 secondi timeout\n    \n    // LibreOffice genera il file con lo stesso nome base dell'input ma con estensione diversa\n    const inputBaseName = path.basename(inputPath, path.extname(inputPath));\n    const expectedOutput = path.join(outputDir, `${inputBaseName}.${outputFormat}`);\n    \n    // Verifica che il file di output esista\n    if (fs.existsSync(expectedOutput)) {\n      return fs.readFileSync(expectedOutput);\n    }\n    \n    // Fallback: cerca qualsiasi file PDF nella directory di output\n    try {\n      const files = fs.readdirSync(outputDir);\n      const pdfFile = files.find(f => f.endsWith('.pdf') || f.endsWith(`.${outputFormat}`));\n      if (pdfFile) {\n        const pdfPath = path.join(outputDir, pdfFile);\n        return fs.readFileSync(pdfPath);\n      }\n    } catch {}\n    \n    return null;\n  } catch (e) {\n    console.error('Errore conversione LibreOffice:', e);\n    return null;\n  }\n}\n\n// Helper per trovare Pandoc su Windows in percorsi comuni\nfunction findPandocWindows() {\n  const possiblePaths = [\n    'C:\\\\Program Files\\\\Pandoc\\\\pandoc.exe',\n    process.env.PROGRAMFILES + '\\\\Pandoc\\\\pandoc.exe',\n    process.env.LOCALAPPDATA + '\\\\Pandoc\\\\pandoc.exe',\n    'C:\\\\Users\\\\' + process.env.USERNAME + '\\\\AppData\\\\Local\\\\Pandoc\\\\pandoc.exe'\n  ];\n  \n  for (const p of possiblePaths) {\n    if (p && fs.existsSync(p)) {\n      return p;\n    }\n  }\n  return null;\n}\n\n// Helper per convertire tramite Pandoc (se disponibile)\nasync function convertViaPandoc(inputPath, outputPath, inputFormat, outputFormat) {\n  const isWindows = process.platform === 'win32';\n  let pandoc = null;\n  \n  if (isWindows) {\n    // Cerca in percorsi comuni\n    pandoc = findPandocWindows();\n    \n    // Verifica anche nel PATH\n    if (!pandoc && await commandExists('pandoc.exe')) {\n      pandoc = 'pandoc.exe';\n    }\n    \n    if (!pandoc) {\n      console.warn('Pandoc non trovato. Per installarlo: https://pandoc.org/installing.html');\n      return null;\n    }\n  } else {\n    // Linux/Mac\n    if (await commandExists('pandoc')) {\n      pandoc = 'pandoc';\n    } else {\n      console.warn('Pandoc non trovato. Installa Pandoc per usare questa funzione.');\n      return null;\n    }\n  }\n  \n  try {\n    const cmd = isWindows \n      ? `\"${pandoc}\" -f ${inputFormat} -t ${outputFormat} -o \"${outputPath}\" \"${inputPath}\"`\n      : `${pandoc} -f ${inputFormat} -t ${outputFormat} -o \"${outputPath}\" \"${inputPath}\"`;\n    await execAsync(cmd, { timeout: 60000 });\n    \n    if (fs.existsSync(outputPath)) {\n      return fs.readFileSync(outputPath);\n    }\n    return null;\n  } catch (e) {\n    console.error('Errore conversione Pandoc:', e);\n    return null;\n  }\n}\n\n// Helper per trovare ddjvu su Windows in percorsi comuni\nfunction findDjvuLibreWindows() {\n  const possiblePaths = [\n    'C:\\\\Program Files\\\\djvulibre\\\\bin\\\\ddjvu.exe',\n    'C:\\\\Program Files (x86)\\\\djvulibre\\\\bin\\\\ddjvu.exe',\n    process.env.PROGRAMFILES + '\\\\djvulibre\\\\bin\\\\ddjvu.exe',\n    process.env['PROGRAMFILES(X86)'] + '\\\\djvulibre\\\\bin\\\\ddjvu.exe'\n  ];\n  \n  for (const p of possiblePaths) {\n    if (p && fs.existsSync(p)) {\n      return p;\n    }\n  }\n  return null;\n}\n\n// Helper per convertire DJVU tramite djvulibre (se disponibile)\nasync function convertDjvuToPdf(inputPath, outputPath) {\n  const isWindows = process.platform === 'win32';\n  let ddjvu = null;\n  \n  if (isWindows) {\n    // Su Windows, djvulibre potrebbe essere in percorsi comuni\n    ddjvu = findDjvuLibreWindows();\n    \n    // Verifica anche nel PATH\n    if (!ddjvu && await commandExists('ddjvu.exe')) {\n      ddjvu = 'ddjvu.exe';\n    }\n    \n    if (!ddjvu) {\n      console.warn('djvulibre non trovato. Per installarlo: https://sourceforge.net/projects/djvu/files/');\n      return null;\n    }\n  } else {\n    // Linux/Mac\n    if (await commandExists('ddjvu')) {\n      ddjvu = 'ddjvu';\n    } else if (fs.existsSync('/usr/bin/ddjvu')) {\n      ddjvu = '/usr/bin/ddjvu';\n    } else {\n      console.warn('djvulibre non trovato. Installa djvulibre per usare questa funzione.');\n      return null;\n    }\n  }\n  \n  try {\n    // ddjvu comando: ddjvu -format=pdf <djvu-file> <pdf-file>\n    const cmd = isWindows \n      ? `\"${ddjvu}\" -format=pdf \"${inputPath}\" \"${outputPath}\"`\n      : `${ddjvu} -format=pdf \"${inputPath}\" \"${outputPath}\"`;\n    await execAsync(cmd, { timeout: 60000 });\n    \n    if (fs.existsSync(outputPath)) {\n      return fs.readFileSync(outputPath);\n    }\n    return null;\n  } catch (e) {\n    console.error('Errore conversione DJVU:', e);\n    return null;\n  }\n}\n\nexport const config = { api: { bodyParser: false } };\n\nfunction toDataUrl(buffer, mime) {\n  // Verifica che il buffer non sia vuoto o null\n  if (!buffer || buffer.length === 0) {\n    // Restituisci un buffer vuoto come fallback\n    buffer = Buffer.from('');\n  }\n  const base64 = buffer.toString('base64');\n  return `data:${mime};base64,${base64}`;\n}\n\nexport default async function handler(req, res) {\n  // Handle CORS preflight\n  if (req.method === 'OPTIONS') {\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n    res.status(200).end();\n    return;\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed', code: 'METHOD_NOT_ALLOWED' });\n  }\n  \n  const { target } = req.query;\n  if (!target) {\n    return handleApiError(new ValidationError('Target format is required'), res, {\n      method: req.method,\n      url: req.url,\n      endpoint: '/api/convert/[target]',\n    });\n  }\n\n  // Su Vercel, usa /tmp per i file temporanei (unico filesystem scrivibile)\n  const tmpDir = process.env.VERCEL ? '/tmp' : os.tmpdir();\n  \n  const form = formidable({ \n    multiples: false, \n    keepExtensions: true,\n    allowEmptyFiles: false, // Non permettere file vuoti\n    maxFileSize: 500 * 1024 * 1024, // 500MB per singolo file\n    maxTotalFileSize: 500 * 1024 * 1024, // 500MB totale\n    uploadDir: tmpDir, // Usa /tmp su Vercel\n  });\n  \n  // Wrappare form.parse in try-catch per gestire errori non gestiti\n  try {\n    form.parse(req, async (err, fields, files) => {\n      // Wrappare tutto il codice del callback in try-catch per gestire errori async\n      try {\n        if (err) {\n      // Gestisci errori specifici di formidable\n      let errorMessage = err.message || 'File upload failed';\n      if (err.message && err.message.includes('file size should be greater than 0')) {\n        errorMessage = 'Il file è vuoto. Carica un file valido.';\n      } else if (err.message && err.message.includes('options.allowEmptyFiles')) {\n        errorMessage = 'Il file caricato è vuoto. Carica un file con contenuto.';\n      } else if (err.message && err.message.includes('maxTotalFileSize')) {\n        errorMessage = 'File troppo grande. Dimensione massima: 500MB per file video/audio, 50MB per altri formati';\n      } else if (err.message && err.message.includes('maxFileSize')) {\n        errorMessage = 'File troppo grande. Dimensione massima: 500MB per file video/audio, 50MB per altri formati';\n      }\n      return handleApiError(\n        new ValidationError(errorMessage, err),\n        res,\n        { method: req.method, url: req.url, endpoint: '/api/convert/[target]' }\n      );\n    }\n    \n    // Formidable v3 restituisce array, v2 restituisce oggetto singolo\n    let file = files.file;\n    if (Array.isArray(file)) {\n      file = file[0]; // Prendi il primo file dall'array\n    }\n    \n    if (!file) {\n      return handleApiError(\n        new ValidationError('File missing'),\n        res,\n        { method: req.method, url: req.url, endpoint: '/api/convert/[target]' }\n      );\n    }\n    \n    // Supporta sia filepath (v2/v3) che path (v1) di formidable\n    const inputPath = file.filepath || file.path;\n    if (!inputPath) {\n      return handleApiError(\n        new ValidationError('File path non valido - il file potrebbe non essere stato caricato correttamente'),\n        res,\n        { method: req.method, url: req.url, endpoint: '/api/convert/[target]' }\n      );\n    }\n    \n    // Valida che il file non sia vuoto\n    if (file.size === 0) {\n      return handleApiError(\n        new ValidationError('Il file è vuoto. Carica un file valido.'),\n        res,\n        { method: req.method, url: req.url, endpoint: '/api/convert/[target]' }\n      );\n    }\n    \n    let inputExt = ''; // Inizializza prima del try block\n    \n    try {\n      // Verifica che inputPath sia valido prima di usarlo\n      if (!inputPath || typeof inputPath !== 'string') {\n        throw new Error('File path non valido - il file potrebbe non essere stato caricato correttamente');\n      }\n      \n      // Verifica che il file esista\n      if (!fs.existsSync(inputPath)) {\n        throw new Error('Il file caricato non esiste più o è stato rimosso');\n      }\n      \n      const originalName = file.originalFilename || file.name || 'file';\n      const inputBuffer = fs.readFileSync(inputPath);\n      inputExt = (path.extname(originalName) || '').replace('.', '').toLowerCase();\n      const lowerTarget = String(target).toLowerCase();\n\n      function finalizeName(name) {\n        const ext = `.${lowerTarget}`;\n        if (name.toLowerCase().endsWith(ext)) return name;\n        const replaced = name.replace(/\\.[^/.]+$/, ext);\n        return replaced.toLowerCase().endsWith(ext) ? replaced : name + ext;\n      }\n\n      let outputBuffer = null;\n      let mime = 'application/octet-stream';\n\n      // Optional options\n      const width = fields.width ? parseInt(String(fields.width)) : undefined;\n      const height = fields.height ? parseInt(String(fields.height)) : undefined;\n      const quality = fields.quality ? parseInt(String(fields.quality)) : 80;\n      const vwidth = fields.vwidth ? parseInt(String(fields.vwidth)) : undefined;\n      const vheight = fields.vheight ? parseInt(String(fields.vheight)) : undefined;\n      const vbitrate = fields.vbitrate ? String(fields.vbitrate) : undefined;\n      const abitrate = fields.abitrate ? String(fields.abitrate) : undefined;\n      const page = fields.page ? parseInt(String(fields.page)) : 0;\n\n      // IMAGE CONVERSIONS via sharp\n      const imageTargets = ['png','jpg','jpeg','webp','tiff','bmp','avif','heif','gif'];\n      if (imageTargets.includes(lowerTarget)) {\n        let pipeline;\n        if (inputExt === 'pdf') {\n          // Render a specific page from PDF if provided (default first page)\n          const p = Number.isFinite(page) && page >= 0 ? page : 0;\n          pipeline = sharp(inputBuffer, { density: 150, page: p });\n        } else {\n          pipeline = sharp(inputBuffer, { failOn: 'none' });\n        }\n        if (width || height) pipeline = pipeline.resize({ width, height, fit: 'inside' });\n        if (lowerTarget === 'jpg' || lowerTarget === 'jpeg') {\n          outputBuffer = await pipeline.jpeg({ quality }).toBuffer();\n          mime = 'image/jpeg';\n        } else if (lowerTarget === 'png') {\n          outputBuffer = await pipeline.png({ compressionLevel: 9 }).toBuffer();\n          mime = 'image/png';\n        } else if (lowerTarget === 'webp') {\n          outputBuffer = await pipeline.webp({ quality }).toBuffer();\n          mime = 'image/webp';\n        } else if (lowerTarget === 'avif') {\n          outputBuffer = await pipeline.avif({ quality }).toBuffer();\n          mime = 'image/avif';\n        } else if (lowerTarget === 'heif') {\n          // heif container (may encode HEIC/HEIF depending on libvips build)\n          outputBuffer = await pipeline.heif({ quality }).toBuffer();\n          mime = 'image/heif';\n        } else if (lowerTarget === 'tiff') {\n          outputBuffer = await pipeline.tiff().toBuffer();\n          mime = 'image/tiff';\n        } else if (lowerTarget === 'bmp') {\n          outputBuffer = await pipeline.bmp().toBuffer();\n          mime = 'image/bmp';\n        } else if (lowerTarget === 'gif') {\n          // Animated GIFs will be flattened to first frame\n          outputBuffer = await pipeline.gif().toBuffer();\n          mime = 'image/gif';\n        }\n      }\n\n      // AUDIO/VIDEO CONVERSIONS via FFmpeg\n      const audioFormats = ['mp3', 'wav', 'aac', 'flac', 'ogg', 'm4a', 'weba', 'opus', 'ac3', 'aif', 'aiff', 'aifc', 'amr', 'au', 'caf', 'dss', 'oga', 'voc', 'wma'];\n      const videoFormats = ['mp4', 'avi', 'mov', 'mkv', 'webm', 'flv', '3gp', '3g2', '3gpp', 'cavs', 'dv', 'dvr', 'm2ts', 'm4v', 'mod', 'mpeg', 'mpg', 'mts', 'mxf', 'ogg', 'ogv', 'rm', 'rmvb', 'swf', 'ts', 'vob', 'wmv', 'wtv'];\n      \n      if (!outputBuffer && (audioFormats.includes(lowerTarget) || videoFormats.includes(lowerTarget))) {\n        try {\n          // Verifica che ffmpeg-static sia disponibile\n          if (!ffmpegStatic) {\n            // Prova a importare dinamicamente se non disponibile\n            const ffmpegStaticDynamic = await import('ffmpeg-static');\n            const ffmpegPath = ffmpegStaticDynamic.default || ffmpegStaticDynamic;\n            if (ffmpegPath) {\n              ffmpeg.setFfmpegPath(ffmpegPath);\n            } else {\n              throw new Error('FFmpeg non disponibile');\n            }\n          } else {\n            // Configura ffmpeg con ottimizzazioni\n            ffmpeg.setFfmpegPath(ffmpegStatic);\n          }\n          \n          // Determina numero ottimale di thread (usa tutti i core disponibili)\n          const threads = os.cpus().length;\n          \n          // Su Vercel, usa /tmp per i file di output\n          const outputDir = process.env.VERCEL ? '/tmp' : path.dirname(inputPath);\n          const outputFilename = `output_${Date.now()}.${lowerTarget}`;\n          const outputPath = path.join(outputDir, outputFilename);\n          \n          await new Promise((resolve, reject) => {\n            let command = ffmpeg(inputPath);\n            \n            // Opzioni globali per velocità - usa tutti i thread disponibili\n            command = command.outputOptions([\n              '-threads', threads.toString() // Multi-threading\n            ]);\n            \n            // Configurazioni specifiche per audio\n            if (audioFormats.includes(lowerTarget)) {\n              // Estrai solo audio\n              command = command.noVideo();\n              \n              // Bitrate audio se specificato\n              if (abitrate) {\n                command = command.audioBitrate(abitrate);\n              } else {\n                // Bitrate OTTIMIZZATI per velocità mantenendo qualità accettabile\n                const defaultBitrates = {\n                  'mp3': '160k',   // Veloce e buona qualità\n                  'aac': '160k',   // Veloce e buona qualità\n                  'm4a': '160k',   // Veloce e buona qualità\n                  'flac': '1411k', // lossless\n                  'wav': '1411k',  // lossless\n                  'ogg': '160k',   // Veloce\n                  'opus': '128k',  // Ottimo per Opus\n                  'weba': '128k'   // Ottimo per WebM audio\n                };\n                const bitrate = defaultBitrates[lowerTarget] || '160k';\n                command = command.audioBitrate(bitrate);\n              }\n              \n              // Codec specifici per formato\n              const audioCodecs = {\n                'mp3': 'libmp3lame',\n                'aac': 'aac',\n                'm4a': 'aac',\n                'flac': 'flac',\n                'wav': 'pcm_s16le',\n                'ogg': 'libvorbis',\n                'opus': 'libopus',\n                'weba': 'libopus',\n                'ac3': 'ac3',\n                'wma': 'wmav2'\n              };\n              \n              if (audioCodecs[lowerTarget]) {\n                command = command.audioCodec(audioCodecs[lowerTarget]);\n              }\n              \n              // Frequenza campionamento ottimizzata\n              command = command.audioFrequency(44100);\n              command = command.audioChannels(2);\n              \n              // Opzioni di velocità per codec specifici\n              if (lowerTarget === 'mp3') {\n                command = command.outputOptions([\n                  '-q:a', '3' // Buon compromesso qualità/velocità per MP3\n                ]);\n              } else if (lowerTarget === 'aac' || lowerTarget === 'm4a') {\n                command = command.outputOptions([\n                  '-profile:a', 'aac_low',\n                  '-movflags', '+faststart' // Start veloce\n                ]);\n              } else if (lowerTarget === 'opus' || lowerTarget === 'weba') {\n                command = command.outputOptions([\n                  '-compression_level', '5' // Compromesso velocità/qualità per Opus\n                ]);\n              }\n            }\n            \n            // Configurazioni specifiche per video\n            if (videoFormats.includes(lowerTarget)) {\n              // Codec video in base al formato\n              const videoCodecs = {\n                'mp4': 'libx264',\n                'webm': 'libvpx',\n                'mkv': 'libx264',\n                'avi': 'libxvid',\n                'mov': 'libx264',\n                'flv': 'flv',\n                'ogv': 'libtheora',\n                '3gp': 'h263',\n                'wmv': 'wmv2'\n              };\n              \n              if (videoCodecs[lowerTarget]) {\n                command = command.videoCodec(videoCodecs[lowerTarget]);\n              }\n              \n              // Bitrate video se specificato\n              if (vbitrate) {\n                command = command.videoBitrate(vbitrate);\n              } else {\n                command = command.videoBitrate('1800k'); // Ridotto leggermente per velocità\n              }\n              \n              // Dimensioni video se specificate\n              if (vwidth && vheight) {\n                command = command.size(`${vwidth}x${vheight}`);\n              } else if (vwidth) {\n                command = command.size(`${vwidth}x?`);\n              } else if (vheight) {\n                command = command.size(`?x${vheight}`);\n              }\n              \n              // Codec audio per video\n              const audioCodecs = {\n                'mp4': 'aac',\n                'webm': 'libvorbis',\n                'mkv': 'aac',\n                'avi': 'libmp3lame',\n                'mov': 'aac',\n                'flv': 'libmp3lame',\n                'ogv': 'libvorbis',\n                '3gp': 'aac',\n                'wmv': 'wmav2'\n              };\n              \n              if (audioCodecs[lowerTarget]) {\n                command = command.audioCodec(audioCodecs[lowerTarget]);\n              }\n              \n              if (abitrate) {\n                command = command.audioBitrate(abitrate);\n              } else {\n                command = command.audioBitrate('160k'); // Ridotto leggermente per velocità\n              }\n              \n              // Frame rate ottimizzato\n              command = command.fps(30);\n              \n              // Formato specifico con preset VERYFAST (ottimo compromesso)\n              if (lowerTarget === 'mp4') {\n                command = command.format('mp4');\n                command = command.outputOptions([\n                  '-movflags', 'faststart',\n                  '-preset', 'veryfast', // VELOCIZZATO: da fast a veryfast\n                  '-crf', '24', // Leggermente ridotto per velocità\n                  '-tune', 'fastdecode' // Ottimizzazione per decodifica veloce\n                ]);\n              } else if (lowerTarget === 'webm') {\n                command = command.format('webm');\n                command = command.outputOptions([\n                  '-deadline', 'good',\n                  '-cpu-used', '5', // VELOCIZZATO: da 4 a 5\n                  '-row-mt', '1' // Multi-threading per righe\n                ]);\n              } else if (lowerTarget === 'mkv') {\n                command = command.format('matroska');\n                command = command.outputOptions([\n                  '-preset', 'veryfast',\n                  '-crf', '24',\n                  '-tune', 'fastdecode'\n                ]);\n              } else if (lowerTarget === 'avi') {\n                command = command.format('avi');\n                command = command.outputOptions([\n                  '-q:v', '6' // Bilanciato\n                ]);\n              } else if (lowerTarget === 'mov') {\n                command = command.format('mov');\n                command = command.outputOptions([\n                  '-preset', 'veryfast',\n                  '-crf', '24',\n                  '-tune', 'fastdecode'\n                ]);\n              } else if (lowerTarget === 'flv') {\n                command = command.format('flv');\n              }\n            }\n            \n            // Esegui conversione\n            command\n              .output(outputPath)\n              .on('end', () => resolve())\n              .on('error', (err) => reject(err))\n              .run();\n          });\n          \n          // Leggi file convertito\n          if (fs.existsSync(outputPath)) {\n            outputBuffer = fs.readFileSync(outputPath);\n            \n            // MIME types\n            const mimeTypes = {\n              // Audio\n              'mp3': 'audio/mpeg',\n              'wav': 'audio/wav',\n              'aac': 'audio/aac',\n              'm4a': 'audio/mp4',\n              'flac': 'audio/flac',\n              'ogg': 'audio/ogg',\n              'oga': 'audio/ogg',\n              'opus': 'audio/opus',\n              'weba': 'audio/webm',\n              'wma': 'audio/x-ms-wma',\n              'ac3': 'audio/ac3',\n              // Video\n              'mp4': 'video/mp4',\n              'webm': 'video/webm',\n              'mkv': 'video/x-matroska',\n              'avi': 'video/x-msvideo',\n              'mov': 'video/quicktime',\n              'flv': 'video/x-flv',\n              'ogv': 'video/ogg',\n              '3gp': 'video/3gpp',\n              'wmv': 'video/x-ms-wmv',\n              'mpeg': 'video/mpeg',\n              'mpg': 'video/mpeg'\n            };\n            \n            mime = mimeTypes[lowerTarget] || 'application/octet-stream';\n            \n            // Cleanup: elimina file temporaneo\n            try {\n              fs.unlinkSync(outputPath);\n            } catch (e) {\n              console.warn('Failed to delete temp output file:', e);\n            }\n          }\n        } catch (ffmpegError) {\n          console.error('FFmpeg conversion error:', ffmpegError);\n          console.error('FFmpeg path:', ffmpegStatic);\n          console.error('FFmpeg error details:', {\n            message: ffmpegError.message,\n            code: ffmpegError.code,\n            errno: ffmpegError.errno,\n            syscall: ffmpegError.syscall\n          });\n          \n          // Se FFmpeg non è disponibile, prova a reimportare dinamicamente\n          if (!ffmpegStatic || ffmpegError.code === 'ENOENT' || ffmpegError.message?.includes('ENOENT') || ffmpegError.message?.includes('not found')) {\n            try {\n              console.log('Tentativo reimport ffmpeg-static...');\n              const ffmpegStaticRetry = await import('ffmpeg-static');\n              const ffmpegPath = ffmpegStaticRetry.default || ffmpegStaticRetry;\n              console.log('FFmpeg path trovato:', ffmpegPath);\n              \n              if (ffmpegPath && fs.existsSync(ffmpegPath)) {\n                // Verifica permessi di esecuzione\n                try {\n                  fs.accessSync(ffmpegPath, fs.constants.X_OK);\n                  console.log('FFmpeg è eseguibile');\n                } catch (permError) {\n                  // Su Vercel/Linux, potrebbe essere necessario rendere eseguibile\n                  try {\n                    fs.chmodSync(ffmpegPath, 0o755);\n                    console.log('Permessi FFmpeg aggiornati');\n                  } catch (chmodError) {\n                    console.warn('Impossibile modificare permessi FFmpeg:', chmodError);\n                  }\n                }\n                \n                // Riprova con il path corretto\n                ffmpeg.setFfmpegPath(ffmpegPath);\n                throw new ProcessingError('FFmpeg trovato, riprova la conversione');\n              } else {\n                throw new ProcessingError(`FFmpeg non trovato nel percorso: ${ffmpegPath || 'undefined'}`);\n              }\n            } catch (retryError) {\n              console.error('Errore reimport FFmpeg:', retryError);\n              throw new ProcessingError(`FFmpeg non disponibile: ${ffmpegError.message || retryError.message || 'Errore sconosciuto'}`);\n            }\n          }\n          \n          // Per altri errori, prova a dare un messaggio più utile\n          throw new ProcessingError(`Conversione audio/video fallita: ${ffmpegError.message || 'Errore durante la conversione con FFmpeg'}`);\n        }\n      }\n\n      // PDF generation\n      if (!outputBuffer && lowerTarget === 'pdf') {\n        // Handle HTML with pdfkit (no Puppeteer dependency)\n        if (inputExt === 'html' || inputExt === 'htm') {\n          const html = inputBuffer.toString('utf8');\n          // Estrai testo dall'HTML\n          let text = html\n            .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n            .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n            .replace(/<[^>]+>/g, ' ')\n            .replace(/&nbsp;/g, ' ')\n            .replace(/&amp;/g, '&')\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&quot;/g, '\"')\n            .replace(/&#39;/g, \"'\")\n            .replace(/\\s+/g, ' ')\n            .trim();\n          \n          const doc = new PDFDocument({ margin: 48 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('end', () => {});\n          doc.fontSize(12).text(text);\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        } else if (inputExt === 'csv') {\n          // Simple table rendering from CSV using pdfkit\n          const doc = new PDFDocument({ margin: 36 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          const text = inputBuffer.toString('utf8');\n          const rows = text.split(/\\r?\\n/).filter(Boolean).map(line => line.split(','));\n          const colWidths = [];\n          const maxCols = rows.reduce((m, r) => Math.max(m, r.length), 0);\n          for (let c = 0; c < maxCols; c++) colWidths[c] = Math.floor((doc.page.width - doc.page.margins.left - doc.page.margins.right) / maxCols);\n          let y = doc.y;\n          const rowHeight = 20;\n          rows.forEach((cols, ri) => {\n            let x = doc.page.margins.left;\n            cols.forEach((cell, ci) => {\n              const w = colWidths[ci] || 80;\n              doc.rect(x, y, w, rowHeight).strokeOpacity(0.3).stroke();\n              doc.fontSize(10).fillColor('#000').text(cell, x + 4, y + 4, { width: w - 8, height: rowHeight - 8, ellipsis: true });\n              x += w;\n            });\n            y += rowHeight;\n            if (y + rowHeight > doc.page.height - doc.page.margins.bottom) {\n              doc.addPage();\n              y = doc.y;\n            }\n          });\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        } else if (inputExt === 'svg') {\n          const doc = new PDFDocument({ autoFirstPage: false });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          doc.addPage({ size: 'A4' });\n          const svgStr = inputBuffer.toString('utf8');\n          SVGtoPDF(doc, svgStr, 0, 0, { preserveAspectRatio: 'xMidYMid meet' });\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        } else if (['png','jpg','jpeg','webp','bmp','gif','tiff'].includes(inputExt)) {\n          const doc = new PDFDocument({ autoFirstPage: false });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          const img = sharp(inputBuffer);\n          const meta = await img.metadata();\n          const pageWidth = (meta.width || 800);\n          const pageHeight = (meta.height || 600);\n          doc.addPage({ size: [pageWidth, pageHeight] });\n          const tmpPath = inputPath + '.tmpimg';\n          fs.writeFileSync(tmpPath, inputBuffer);\n          doc.image(tmpPath, 0, 0, { width: pageWidth, height: pageHeight });\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          fs.unlinkSync(tmpPath);\n          mime = 'application/pdf';\n        } else {\n          // Text-like pdf\n          const doc = new PDFDocument({ margin: 48 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          const content = inputBuffer.toString('utf8');\n          doc.fontSize(12).text(content);\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        }\n      }\n      // AI -> PDF (embedded PDF extraction)\n      if (!outputBuffer && lowerTarget === 'pdf' && inputExt === 'ai') {\n        const bin = inputBuffer.toString('binary');\n        const start = bin.indexOf('%PDF-');\n        const end = bin.lastIndexOf('%%EOF');\n        if (start !== -1 && end !== -1 && end > start) {\n          const pdfBinary = bin.substring(start, end + 5);\n          outputBuffer = Buffer.from(pdfBinary, 'binary');\n          mime = 'application/pdf';\n        }\n      }\n\n      // DJVU -> PDF (via djvulibre)\n      if (!outputBuffer && lowerTarget === 'pdf' && inputExt === 'djvu') {\n        const tmpOut = path.join(path.dirname(inputPath), `djvu_${Date.now()}.pdf`);\n        const result = await convertDjvuToPdf(inputPath, tmpOut);\n        if (result) {\n          outputBuffer = result;\n          mime = 'application/pdf';\n          try { fs.unlinkSync(tmpOut); } catch {}\n        }\n      }\n\n      // Document formats to PDF via LibreOffice\n      const libreOfficeDocFormats = ['pub', 'xps', 'abw', 'zabw', 'doc', 'docm', 'dot', 'dotx', 'hwp', 'lwp', 'wpd', 'wps', 'pages', 'odt', 'ods', 'odp', 'odg', 'rtf', 'rst'];\n      if (!outputBuffer && lowerTarget === 'pdf' && libreOfficeDocFormats.includes(inputExt)) {\n        // Su Vercel, usa /tmp per i file temporanei\n        const workDir = process.env.VERCEL ? '/tmp' : path.dirname(inputPath);\n        const result = await convertViaLibreOffice(inputPath, workDir, 'pdf');\n        if (result) {\n          outputBuffer = result;\n          mime = 'application/pdf';\n        } else {\n          // LibreOffice non disponibile, informiamo l'utente\n          return handleApiError(\n            new ProcessingError(`Conversione ${inputExt.toUpperCase()} → PDF richiede LibreOffice. Per favore, installa LibreOffice per usare questa funzionalità. Download: https://www.libreoffice.org/download/`),\n            res,\n            {\n              method: req.method,\n              url: req.url,\n              endpoint: '/api/convert/[target]',\n              target,\n              inputExt,\n              hint: 'LibreOffice non è installato sul server'\n            }\n          );\n        }\n      }\n\n      // TXT extraction/conversion\n      if (!outputBuffer && lowerTarget === 'txt') {\n        if (inputExt === 'txt') {\n          // TXT → TXT: pass-through, ma normalizziamo l'encoding\n          try {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from(inputBuffer.toString('binary'), 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'pdf') {\n          try {\n            const parsed = await pdfParse(inputBuffer);\n            outputBuffer = Buffer.from(parsed.text || '', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'docx' || inputExt === 'docm' || inputExt === 'dotx') {\n          try {\n            const { value } = await mammoth.extractRawText({ buffer: inputBuffer });\n            outputBuffer = Buffer.from(value || '', 'utf8');\n            mime = 'text/plain';\n          } catch {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'doc' || inputExt === 'dot') {\n          // DOC/DOT legacy: prova con mammoth, altrimenti parsing base\n          try {\n            const { value } = await mammoth.extractRawText({ buffer: inputBuffer });\n            outputBuffer = Buffer.from(value || '', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            // Fallback: estrai testo grezzo\n            const text = inputBuffer.toString('utf8', 0, Math.min(50000, inputBuffer.length));\n            const cleanText = text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, ' ').trim();\n            outputBuffer = Buffer.from(cleanText || 'Contenuto non estraibile da formato DOC legacy', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'html' || inputExt === 'htm') {\n          // HTML → TXT: estrai solo il testo, rimuovendo i tag HTML\n          try {\n            const html = inputBuffer.toString('utf8');\n            // Rimuovi script e style\n            let text = html.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '');\n            text = text.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '');\n            // Sostituisci i tag HTML con spazi\n            text = text.replace(/<[^>]+>/g, ' ');\n            // Decodifica entità HTML\n            text = text.replace(/&nbsp;/g, ' ');\n            text = text.replace(/&amp;/g, '&');\n            text = text.replace(/&lt;/g, '<');\n            text = text.replace(/&gt;/g, '>');\n            text = text.replace(/&quot;/g, '\"');\n            text = text.replace(/&#39;/g, \"'\");\n            // Rimuovi spazi multipli e newline\n            text = text.replace(/\\s+/g, ' ').trim();\n            outputBuffer = Buffer.from(text, 'utf8');\n          } catch (e) {\n            // Fallback: restituisci HTML come testo\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n          }\n        } else if (inputExt === 'md') {\n          // MD → TXT: Markdown è già testo, ma rimuoviamo la sintassi markdown di base\n          try {\n            const md = inputBuffer.toString('utf8');\n            let text = md;\n            // Rimuovi sintassi Markdown comune\n            text = text.replace(/#{1,6}\\s+/g, ''); // Headers\n            text = text.replace(/\\*\\*([^*]+)\\*\\*/g, '$1'); // Bold\n            text = text.replace(/\\*([^*]+)\\*/g, '$1'); // Italic\n            text = text.replace(/\\[([^\\]]+)\\]\\([^\\)]+\\)/g, '$1'); // Links\n            text = text.replace(/`([^`]+)`/g, '$1'); // Inline code\n            text = text.replace(/```[\\s\\S]*?```/g, ''); // Code blocks\n            outputBuffer = Buffer.from(text, 'utf8');\n          } catch (e) {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n          }\n        } else if (inputExt === 'rtf') {\n          // RTF → TXT: già gestito sopra, ma assicuriamoci che funzioni\n          try {\n            const rtfText = inputBuffer.toString('utf8');\n            let plainText = rtfText;\n            plainText = plainText.replace(/\\\\[a-z]+\\d*\\s?/gi, ' ');\n            plainText = plainText.replace(/\\{[^}]*\\}/g, '');\n            plainText = plainText.replace(/\\\\[{}]/g, '');\n            plainText = plainText.replace(/\\s+/g, ' ').trim();\n            outputBuffer = Buffer.from(plainText, 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'odt') {\n          // ODT → TXT: estrai da content.xml\n          try {\n            const zip = await JSZip.loadAsync(inputBuffer);\n            let content = '';\n            if (zip.files['content.xml']) {\n              const xmlContent = await zip.files['content.xml'].async('string');\n              const textMatches = xmlContent.match(/<text:[^>]*>([^<]*)<\\/text:[^>]*>/gi) || [];\n              const texts = textMatches.map(m => {\n                const match = m.match(/>([^<]+)</i);\n                return match ? match[1] : '';\n              }).filter(t => t.trim().length > 0);\n              content = texts.join('\\n');\n              if (!content) {\n                content = xmlContent.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n              }\n            }\n            outputBuffer = Buffer.from(content || 'Contenuto non estraibile', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'abw' || inputExt === 'zabw') {\n          // ABW/ZABW → TXT\n          try {\n            let content = '';\n            if (inputExt === 'zabw') {\n              const zip = await JSZip.loadAsync(inputBuffer);\n              const file = zip.files['content.xml'] || zip.files['AbiWord'];\n              if (file) {\n                const text = await file.async('string');\n                content = text.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n              }\n            } else {\n              const text = inputBuffer.toString('utf8');\n              content = text.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n            }\n            outputBuffer = Buffer.from(content || 'Contenuto non estraibile', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'tex' || inputExt === 'rst') {\n          // TEX/RST → TXT: sono formati testuali\n          try {\n            const text = inputBuffer.toString('utf8');\n            outputBuffer = Buffer.from(text, 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (['pub', 'xps', 'hwp', 'lwp', 'pages', 'wpd', 'wps'].includes(inputExt)) {\n          // Formati complessi → TXT: prova parsing base\n          try {\n            // Prova come archivio ZIP (XPS, PAGES potrebbero essere ZIP)\n            if (inputExt === 'xps' || inputExt === 'pages') {\n              try {\n                const zip = await JSZip.loadAsync(inputBuffer);\n                let content = '';\n                for (const [path, file] of Object.entries(zip.files)) {\n                  if (path.endsWith('.xml') || path.endsWith('.txt')) {\n                    const text = await file.async('string');\n                    content += text.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim() + '\\n';\n                  }\n                }\n                outputBuffer = Buffer.from(content || 'Contenuto non estraibile', 'utf8');\n                mime = 'text/plain';\n              } catch (e) {\n                // Non è un ZIP, prova parsing diretto\n                const text = inputBuffer.toString('utf8', 0, Math.min(10000, inputBuffer.length));\n                const cleanText = text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, ' ').trim();\n                outputBuffer = Buffer.from(cleanText || 'Contenuto non estraibile', 'utf8');\n                mime = 'text/plain';\n              }\n            } else {\n              // Altri formati binari: estrazione base\n              const text = inputBuffer.toString('utf8', 0, Math.min(10000, inputBuffer.length));\n              const cleanText = text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, ' ').trim();\n              outputBuffer = Buffer.from(cleanText || `Formato ${inputExt.toUpperCase()} richiede tool specializzati per estrazione completa`, 'utf8');\n              mime = 'text/plain';\n            }\n          } catch (e) {\n            outputBuffer = Buffer.from('', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'djvu') {\n          // DJVU → TXT: formato binario complesso\n          outputBuffer = Buffer.from('DJVU è un formato binario complesso. Per estrarre testo serve djvulibre.', 'utf8');\n          mime = 'text/plain';\n        } else {\n          // Per altri formati testuali, converti in UTF-8\n          try {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n          } catch (e) {\n            // Se fallisce, prova a leggere come binary e convertire\n            outputBuffer = Buffer.from(inputBuffer.toString('binary'), 'utf8');\n          }\n        }\n        mime = 'text/plain';\n      }\n\n      // HTML conversion\n      if (!outputBuffer && lowerTarget === 'html') {\n        if (inputExt === 'html' || inputExt === 'htm') {\n          // HTML → HTML: pass-through ma normalizziamo\n          try {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n            mime = 'text/html';\n          } catch (e) {\n            outputBuffer = Buffer.from(inputBuffer.toString('binary'), 'utf8');\n            mime = 'text/html';\n          }\n        } else if (inputExt === 'md') {\n          // MD → HTML: già gestito sopra\n          try {\n            const html = marked.parse(inputBuffer.toString('utf8'));\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } catch (e) {\n            // Fallback: incapsula il markdown come pre\n            const escaped = inputBuffer.toString('utf8').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n            outputBuffer = Buffer.from(`<!DOCTYPE html>\\n<html><head><meta charset=\"UTF-8\"></head><body><pre>${escaped}</pre></body></html>`, 'utf8');\n            mime = 'text/html';\n          }\n        } else if (inputExt === 'txt') {\n          // TXT → HTML: formatta il testo in HTML\n          try {\n            const text = inputBuffer.toString('utf8');\n            // Converti newline in <br> e paragrafi in <p>\n            const lines = text.split(/\\r?\\n/);\n            let html = '<!DOCTYPE html>\\n<html lang=\"it\">\\n<head>\\n<meta charset=\"UTF-8\">\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n<title>Documento convertito</title>\\n<style>\\nbody { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }\\np { margin-bottom: 1em; }\\n</style>\\n</head>\\n<body>\\n';\n            \n            let paragraph = '';\n            lines.forEach(line => {\n              const trimmed = line.trim();\n              if (trimmed === '') {\n                if (paragraph) {\n                  html += `<p>${paragraph.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>\\n`;\n                  paragraph = '';\n                }\n              } else {\n                if (paragraph) paragraph += ' ';\n                paragraph += trimmed;\n              }\n            });\n            if (paragraph) {\n              html += `<p>${paragraph.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>\\n`;\n            }\n            \n            html += '</body>\\n</html>';\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } catch (e) {\n            // Fallback: incapsula il testo in un HTML base\n            const escaped = inputBuffer.toString('utf8').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n            const html = `<!DOCTYPE html>\\n<html><head><meta charset=\"UTF-8\"></head><body><pre>${escaped}</pre></body></html>`;\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          }\n        } else if (inputExt === 'docx') {\n          // DOCX → HTML: già gestito sopra\n          try {\n            const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } catch (e) {\n            outputBuffer = Buffer.from('<html><body><p>Errore nella conversione DOCX</p></body></html>', 'utf8');\n            mime = 'text/html';\n          }\n        }\n      }\n\n      // Markdown (MD) conversion\n      if (!outputBuffer && lowerTarget === 'md') {\n        if (inputExt === 'md') {\n          // MD → MD: pass-through\n          try {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n            mime = 'text/markdown';\n          } catch (e) {\n            outputBuffer = Buffer.from(inputBuffer.toString('binary'), 'utf8');\n            mime = 'text/markdown';\n          }\n        } else if (inputExt === 'html' || inputExt === 'htm') {\n          // HTML → MD: conversione base HTML a Markdown\n          try {\n            const html = inputBuffer.toString('utf8');\n            let md = html;\n            // Rimuovi script e style\n            md = md.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '');\n            md = md.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '');\n            // Converti headers\n            md = md.replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n\\n');\n            md = md.replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n\\n');\n            md = md.replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n\\n');\n            md = md.replace(/<h4[^>]*>(.*?)<\\/h4>/gi, '#### $1\\n\\n');\n            md = md.replace(/<h5[^>]*>(.*?)<\\/h5>/gi, '##### $1\\n\\n');\n            md = md.replace(/<h6[^>]*>(.*?)<\\/h6>/gi, '###### $1\\n\\n');\n            // Converti link\n            md = md.replace(/<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');\n            // Converti bold e italic\n            md = md.replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**');\n            md = md.replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**');\n            md = md.replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*');\n            md = md.replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*');\n            // Converti paragrafi\n            md = md.replace(/<p[^>]*>(.*?)<\\/p>/gi, '$1\\n\\n');\n            // Rimuovi tutti gli altri tag\n            md = md.replace(/<[^>]+>/g, '');\n            // Decodifica entità HTML\n            md = md.replace(/&nbsp;/g, ' ');\n            md = md.replace(/&amp;/g, '&');\n            md = md.replace(/&lt;/g, '<');\n            md = md.replace(/&gt;/g, '>');\n            md = md.replace(/&quot;/g, '\"');\n            md = md.replace(/&#39;/g, \"'\");\n            // Pulisci spazi multipli e newline\n            md = md.replace(/\\n{3,}/g, '\\n\\n').trim();\n            outputBuffer = Buffer.from(md, 'utf8');\n            mime = 'text/markdown';\n          } catch (e) {\n            // Fallback: estrai solo testo\n            let text = inputBuffer.toString('utf8').replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n            outputBuffer = Buffer.from(text, 'utf8');\n            mime = 'text/markdown';\n          }\n        } else if (inputExt === 'txt') {\n          // TXT → MD: principalmente pass-through, ma possiamo formattare meglio\n          try {\n            const text = inputBuffer.toString('utf8');\n            // Se il testo ha pattern che suggeriscono struttura, possiamo convertirli\n            // Per ora, restituiamo come markdown puro\n            outputBuffer = Buffer.from(text, 'utf8');\n            mime = 'text/markdown';\n          } catch (e) {\n            outputBuffer = Buffer.from(inputBuffer.toString('utf8'), 'utf8');\n            mime = 'text/markdown';\n          }\n        } else if (inputExt === 'docx') {\n          // DOCX → MD: converte prima in HTML, poi in MD\n          try {\n            const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n            // Ora converti HTML in MD (riuso la logica sopra)\n            let md = html;\n            md = md.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '');\n            md = md.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '');\n            md = md.replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n\\n');\n            md = md.replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n\\n');\n            md = md.replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n\\n');\n            md = md.replace(/<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi, '[$2]($1)');\n            md = md.replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**');\n            md = md.replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**');\n            md = md.replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*');\n            md = md.replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*');\n            md = md.replace(/<p[^>]*>(.*?)<\\/p>/gi, '$1\\n\\n');\n            md = md.replace(/<[^>]+>/g, '');\n            md = md.replace(/&nbsp;/g, ' ');\n            md = md.replace(/&amp;/g, '&');\n            md = md.replace(/&lt;/g, '<');\n            md = md.replace(/&gt;/g, '>');\n            md = md.replace(/&quot;/g, '\"');\n            md = md.replace(/&#39;/g, \"'\");\n            md = md.replace(/\\n{3,}/g, '\\n\\n').trim();\n            outputBuffer = Buffer.from(md, 'utf8');\n            mime = 'text/markdown';\n          } catch (e) {\n            // Fallback: estrai solo testo\n            try {\n              const { value } = await mammoth.extractRawText({ buffer: inputBuffer });\n              outputBuffer = Buffer.from(value || '', 'utf8');\n              mime = 'text/markdown';\n            } catch {\n              outputBuffer = Buffer.from('', 'utf8');\n              mime = 'text/markdown';\n            }\n          }\n        }\n      }\n\n      // CSV/XLSX\n      if (!outputBuffer && lowerTarget === 'csv' && ['xlsx', 'xls', 'ods'].includes(inputExt)) {\n        const wb = XLSX.read(inputBuffer, { type: 'buffer' });\n        const firstSheet = wb.SheetNames[0];\n        const csv = XLSX.utils.sheet_to_csv(wb.Sheets[firstSheet]);\n        outputBuffer = Buffer.from(csv, 'utf8');\n        mime = 'text/csv';\n      }\n      if (!outputBuffer && lowerTarget === 'xlsx' && ['csv','txt','ods','xls'].includes(inputExt)) {\n        if (inputExt === 'csv' || inputExt === 'txt') {\n          const text = inputBuffer.toString('utf8');\n          const rows = text.split(/\\r?\\n/).filter(Boolean).map(line => line.split(','));\n          const ws = XLSX.utils.aoa_to_sheet(rows);\n          const wb = XLSX.utils.book_new();\n          XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');\n          outputBuffer = Buffer.from(XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }));\n        } else {\n          const wb = XLSX.read(inputBuffer, { type: 'buffer' });\n          outputBuffer = Buffer.from(XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }));\n        }\n        mime = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n      }\n\n      // DOCX -> PDF (HTML è gestito nella sezione HTML conversion)\n      if (!outputBuffer && lowerTarget === 'pdf' && inputExt === 'docx') {\n        try {\n          const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n          // Estrai testo dall'HTML e genera PDF con pdfkit\n          let text = html\n            .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n            .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n            .replace(/<[^>]+>/g, ' ')\n            .replace(/&nbsp;/g, ' ')\n            .replace(/&amp;/g, '&')\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&quot;/g, '\"')\n            .replace(/&#39;/g, \"'\")\n            .replace(/\\s+/g, ' ')\n            .trim();\n          \n          const doc = new PDFDocument({ margin: 48 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('end', () => {});\n          doc.fontSize(12).text(text);\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        } catch {}\n      }\n\n      // Formati Word legacy: DOC, DOCM, DOT, DOTX -> PDF/TXT/HTML\n      const wordFormats = ['doc', 'docm', 'dot', 'dotx'];\n      if (!outputBuffer && wordFormats.includes(inputExt)) {\n        try {\n          // Prova con mammoth (potrebbe funzionare per alcuni formati moderni)\n          if (inputExt === 'docm' || inputExt === 'dotx') {\n            if (lowerTarget === 'txt') {\n              const { value } = await mammoth.extractRawText({ buffer: inputBuffer });\n              outputBuffer = Buffer.from(value || '', 'utf8');\n              mime = 'text/plain';\n            } else if (lowerTarget === 'html') {\n              const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n              outputBuffer = Buffer.from(html, 'utf8');\n              mime = 'text/html';\n            } else if (lowerTarget === 'pdf') {\n              const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n              // Estrai testo e genera PDF con pdfkit\n              let text = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n              const doc = new PDFDocument({ margin: 48 });\n              const chunks = [];\n              doc.on('data', d => chunks.push(d));\n              doc.on('end', () => {});\n              doc.fontSize(12).text(text);\n              doc.end();\n              await new Promise(resolve => doc.on('end', resolve));\n              outputBuffer = Buffer.concat(chunks);\n              mime = 'application/pdf';\n            }\n          } else if (inputExt === 'doc' || inputExt === 'dot') {\n            // DOC e DOT sono binari legacy\n            if (lowerTarget === 'txt') {\n              // Prova con mammoth per estrarre testo\n              try {\n                const { value } = await mammoth.extractRawText({ buffer: inputBuffer });\n                outputBuffer = Buffer.from(value || '', 'utf8');\n                mime = 'text/plain';\n              } catch (e) {\n                // Fallback: estrai testo grezzo\n                const text = inputBuffer.toString('utf8', 0, Math.min(50000, inputBuffer.length));\n                const cleanText = text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F]/g, ' ').trim();\n                outputBuffer = Buffer.from(cleanText || 'Contenuto non estraibile da formato DOC legacy', 'utf8');\n                mime = 'text/plain';\n              }\n            } else if (lowerTarget === 'pdf') {\n              // Prova prima con LibreOffice\n              try {\n                const tmpDir = path.dirname(inputPath);\n                const outputFileName = path.basename(originalName, path.extname(originalName)) + '.pdf';\n                const outputPath = path.join(tmpDir, `lo_${Date.now()}_${outputFileName}`);\n                \n                const convertedBuffer = await convertViaLibreOffice(inputPath, outputPath, 'pdf');\n                if (convertedBuffer) {\n                  outputBuffer = convertedBuffer;\n                  mime = 'application/pdf';\n                  // Cleanup\n                  try { fs.unlinkSync(outputPath); } catch {}\n                } else {\n                  // Fallback: prova con mammoth + pdfkit\n                  try {\n                    const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n                    // Usa pdfkit invece di html-pdf-node\n                    const chunks = [];\n                    const doc = new PDFDocument({ size: 'A4', margin: 50 });\n                    doc.on('data', chunk => chunks.push(chunk));\n                    doc.on('end', () => {});\n                    \n                    let text = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n                    doc.fontSize(12).text(text);\n                    doc.end();\n                    await new Promise(resolve => doc.on('end', resolve));\n                    \n                    outputBuffer = Buffer.concat(chunks);\n                    mime = 'application/pdf';\n                  } catch (e2) {\n                    outputBuffer = Buffer.from('I formati DOC e DOT (Word legacy) richiedono LibreOffice installato. Installa LibreOffice e riprova.', 'utf8');\n                    mime = 'text/plain';\n                  }\n                }\n              } catch (e) {\n                console.error('Errore conversione DOC/DOT:', e);\n                // Fallback: prova con mammoth + pdfkit\n                try {\n                  const { value: html } = await mammoth.convertToHtml({ buffer: inputBuffer });\n                  const chunks = [];\n                  const doc = new PDFDocument({ size: 'A4', margin: 50 });\n                  doc.on('data', chunk => chunks.push(chunk));\n                  doc.on('end', () => {});\n                  \n                  let text = html.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n                  doc.fontSize(12).text(text);\n                  doc.end();\n                  await new Promise(resolve => doc.on('end', resolve));\n                  \n                  outputBuffer = Buffer.concat(chunks);\n                  mime = 'application/pdf';\n                } catch (e2) {\n                  outputBuffer = Buffer.from('I formati DOC e DOT (Word legacy) richiedono LibreOffice installato.', 'utf8');\n                  mime = 'text/plain';\n                }\n              }\n            }\n          }\n        } catch (e) {\n          console.error('Errore conversione Word:', e);\n        }\n      }\n\n      // RTF -> PDF/TXT/HTML\n      if (!outputBuffer && inputExt === 'rtf' && (lowerTarget === 'pdf' || lowerTarget === 'txt' || lowerTarget === 'html')) {\n        try {\n          const rtfText = inputBuffer.toString('utf8');\n          let plainText = rtfText;\n          \n          // Rimozione base dei codici RTF\n          plainText = plainText.replace(/\\\\[a-z]+\\d*\\s?/gi, ' '); // Comandi RTF\n          plainText = plainText.replace(/\\{[^}]*\\}/g, ''); // Gruppi RTF\n          plainText = plainText.replace(/\\s+/g, ' ').trim();\n          \n          if (lowerTarget === 'txt') {\n            outputBuffer = Buffer.from(plainText, 'utf8');\n            mime = 'text/plain';\n          } else if (lowerTarget === 'html') {\n            const html = `<!DOCTYPE html>\\n<html><head><meta charset=\"UTF-8\"></head><body><pre>${plainText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre></body></html>`;\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } else if (lowerTarget === 'pdf') {\n            // Genera PDF direttamente con pdfkit\n            const doc = new PDFDocument({ margin: 48 });\n            const chunks = [];\n            doc.on('data', d => chunks.push(d));\n            doc.on('end', () => {});\n            doc.fontSize(12).text(plainText);\n            doc.end();\n            await new Promise(resolve => doc.on('end', resolve));\n            outputBuffer = Buffer.concat(chunks);\n            mime = 'application/pdf';\n          }\n        } catch (e) {\n          console.error('Errore conversione RTF:', e);\n        }\n      }\n\n      // ODT -> PDF/TXT/HTML (ODT è un archivio ZIP con content.xml)\n      if (!outputBuffer && inputExt === 'odt' && (lowerTarget === 'pdf' || lowerTarget === 'txt' || lowerTarget === 'html')) {\n        try {\n          const zip = await JSZip.loadAsync(inputBuffer);\n          let content = '';\n          \n          if (zip.files['content.xml']) {\n            const xmlContent = await zip.files['content.xml'].async('string');\n            content = xmlContent.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n          } else {\n            content = 'Impossibile estrarre contenuto da ODT.';\n          }\n          \n          if (lowerTarget === 'txt') {\n            outputBuffer = Buffer.from(content, 'utf8');\n            mime = 'text/plain';\n          } else if (lowerTarget === 'html') {\n            const html = `<!DOCTYPE html>\\n<html><head><meta charset=\"UTF-8\"></head><body><p>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p></body></html>`;\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } else if (lowerTarget === 'pdf') {\n            // Genera PDF direttamente con pdfkit\n            const doc = new PDFDocument({ margin: 48 });\n            const chunks = [];\n            doc.on('data', d => chunks.push(d));\n            doc.on('end', () => {});\n            doc.fontSize(12).text(content);\n            doc.end();\n            await new Promise(resolve => doc.on('end', resolve));\n            outputBuffer = Buffer.concat(chunks);\n            mime = 'application/pdf';\n          }\n        } catch (e) {\n          console.error('Errore conversione ODT:', e);\n        }\n      }\n\n      // ABW/ZABW -> PDF/TXT/HTML\n      if (!outputBuffer && (inputExt === 'abw' || inputExt === 'zabw') && (lowerTarget === 'pdf' || lowerTarget === 'txt' || lowerTarget === 'html')) {\n        try {\n          let content = '';\n          if (inputExt === 'zabw') {\n            const zip = await JSZip.loadAsync(inputBuffer);\n            const file = zip.files['content.xml'] || zip.files['AbiWord'];\n            if (file) {\n              const text = await file.async('string');\n              content = text.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n            }\n          } else {\n            content = inputBuffer.toString('utf8');\n            content = content.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim();\n          }\n          \n          if (!content) content = 'Impossibile estrarre contenuto dal file.';\n          \n          if (lowerTarget === 'txt') {\n            outputBuffer = Buffer.from(content, 'utf8');\n            mime = 'text/plain';\n          } else if (lowerTarget === 'html') {\n            const html = `<!DOCTYPE html>\\n<html><head><meta charset=\"UTF-8\"></head><body><p>${content.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p></body></html>`;\n            outputBuffer = Buffer.from(html, 'utf8');\n            mime = 'text/html';\n          } else if (lowerTarget === 'pdf') {\n            // Genera PDF direttamente con pdfkit\n            const doc = new PDFDocument({ margin: 48 });\n            const chunks = [];\n            doc.on('data', d => chunks.push(d));\n            doc.on('end', () => {});\n            doc.fontSize(12).text(content);\n            doc.end();\n            await new Promise(resolve => doc.on('end', resolve));\n            outputBuffer = Buffer.concat(chunks);\n            mime = 'application/pdf';\n          }\n        } catch (e) {\n          console.error('Errore conversione ABW/ZABW:', e);\n        }\n      }\n\n      // DJVU -> PDF (special handling)\n      if (!outputBuffer && inputExt === 'djvu' && lowerTarget === 'pdf') {\n        try {\n          const tmpDir = path.dirname(inputPath);\n          const outputFileName = path.basename(originalName, path.extname(originalName)) + '.pdf';\n          const outputPath = path.join(tmpDir, `djvu_${Date.now()}_${outputFileName}`);\n          \n          const convertedBuffer = await convertDjvuToPdf(inputPath, outputPath);\n          if (convertedBuffer) {\n            outputBuffer = convertedBuffer;\n            mime = 'application/pdf';\n            // Cleanup\n            try { fs.unlinkSync(outputPath); } catch {}\n          } else {\n            outputBuffer = Buffer.from('DJVU richiede djvulibre installato. Installa djvulibre e riprova.', 'utf8');\n            mime = 'text/plain';\n          }\n        } catch (e) {\n          console.error('Errore conversione DJVU:', e);\n          outputBuffer = Buffer.from('DJVU richiede djvulibre installato. Errore: ' + e.message, 'utf8');\n          mime = 'text/plain';\n        }\n      }\n\n      // Formati complessi: prova prima con LibreOffice/Pandoc, poi messaggio informativo\n      const complexFormats = {\n        'pub': { tool: 'libreoffice', format: 'pdf', msg: 'Microsoft Publisher richiede LibreOffice installato.' },\n        'xps': { tool: 'libreoffice', format: 'pdf', msg: 'XPS richiede LibreOffice installato.' },\n        'hwp': { tool: 'libreoffice', format: 'pdf', msg: 'HWP (Hancom Word) richiede LibreOffice installato.' },\n        'lwp': { tool: 'libreoffice', format: 'pdf', msg: 'LWP (Lotus Word Pro) richiede LibreOffice installato.' },\n        'pages': { tool: 'libreoffice', format: 'pdf', msg: 'Apple Pages richiede LibreOffice installato.' },\n        'wpd': { tool: 'libreoffice', format: 'pdf', msg: 'WordPerfect richiede LibreOffice installato.' },\n        'wps': { tool: 'libreoffice', format: 'pdf', msg: 'WPS richiede LibreOffice installato.' },\n        'tex': { tool: 'pandoc', format: 'pdf', msg: 'LaTeX richiede Pandoc o pdflatex installato.' },\n        'rst': { tool: 'pandoc', format: 'pdf', msg: 'reStructuredText richiede Pandoc installato.' }\n      };\n      \n      if (!outputBuffer && complexFormats[inputExt] && lowerTarget === 'pdf') {\n        const formatInfo = complexFormats[inputExt];\n        \n        try {\n          // Prova conversione tramite LibreOffice\n          if (formatInfo.tool === 'libreoffice') {\n            const tmpDir = path.dirname(inputPath);\n            const outputDir = path.join(tmpDir, `lo_output_${Date.now()}`);\n            \n            // Crea directory temporanea per output LibreOffice\n            if (!fs.existsSync(outputDir)) {\n              fs.mkdirSync(outputDir, { recursive: true });\n            }\n            \n            const convertedBuffer = await convertViaLibreOffice(inputPath, outputDir, 'pdf');\n            if (convertedBuffer) {\n              outputBuffer = convertedBuffer;\n              mime = 'application/pdf';\n              \n              // Cleanup: rimuovi tutti i file temporanei nella directory di output\n              try {\n                const files = fs.readdirSync(outputDir);\n                files.forEach(file => {\n                  try { fs.unlinkSync(path.join(outputDir, file)); } catch {}\n                });\n                fs.rmdirSync(outputDir);\n              } catch {}\n            }\n          }\n          \n          // Prova conversione tramite Pandoc (per RST, TEX, ecc.)\n          if (!outputBuffer && formatInfo.tool === 'pandoc') {\n            const tmpDir = path.dirname(inputPath);\n            const outputFileName = path.basename(originalName, path.extname(originalName)) + '.pdf';\n            const outputPath = path.join(tmpDir, `pandoc_${Date.now()}_${outputFileName}`);\n            \n            const convertedBuffer = await convertViaPandoc(inputPath, outputPath, inputExt, 'pdf');\n            if (convertedBuffer) {\n              outputBuffer = convertedBuffer;\n              mime = 'application/pdf';\n              // Cleanup\n              try { fs.unlinkSync(outputPath); } catch {}\n            }\n          }\n          \n          // Se non è stato possibile convertire, restituisci messaggio informativo\n          if (!outputBuffer) {\n            outputBuffer = Buffer.from(`${formatInfo.msg} Installa ${formatInfo.tool} e riprova.`, 'utf8');\n            mime = 'text/plain';\n          }\n        } catch (e) {\n          console.error(`Errore conversione ${inputExt}:`, e);\n          outputBuffer = Buffer.from(`${formatInfo.msg} Errore: ${e.message}`, 'utf8');\n          mime = 'text/plain';\n        }\n      }\n\n      // XLS/XLSX -> PDF\n      if (!outputBuffer && lowerTarget === 'pdf' && ['xls', 'xlsx', 'ods'].includes(inputExt)) {\n        try {\n          const wb = XLSX.read(inputBuffer, { type: 'buffer' });\n          const doc = new PDFDocument({ margin: 36 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          \n          wb.SheetNames.forEach((sheetName, sheetIndex) => {\n            if (sheetIndex > 0) doc.addPage();\n            const ws = wb.Sheets[sheetName];\n            const data = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '' });\n            \n            doc.fontSize(16).text(sheetName, { align: 'center' });\n            doc.moveDown();\n            \n            if (data.length > 0) {\n              const colWidths = [];\n              const maxCols = data.reduce((m, r) => Math.max(m, r.length), 0);\n              const pageWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;\n              for (let c = 0; c < maxCols; c++) colWidths[c] = Math.floor(pageWidth / maxCols);\n              \n              let y = doc.y;\n              const rowHeight = 20;\n              data.forEach((row, ri) => {\n                if (y + rowHeight > doc.page.height - doc.page.margins.bottom) {\n                  doc.addPage();\n                  y = doc.y;\n                }\n                let x = doc.page.margins.left;\n                row.forEach((cell, ci) => {\n                  const w = colWidths[ci] || 80;\n                  doc.rect(x, y, w, rowHeight).strokeOpacity(0.3).stroke();\n                  doc.fontSize(9).fillColor('#000').text(String(cell || ''), x + 4, y + 4, { width: w - 8, height: rowHeight - 8, ellipsis: true });\n                  x += w;\n                });\n                y += rowHeight;\n              });\n            }\n          });\n          \n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        } catch {}\n      }\n\n      // PDF -> PPTX (basic text extraction)\n      if (!outputBuffer && lowerTarget === 'pptx' && inputExt === 'pdf') {\n        try {\n          const parsed = await pdfParse(inputBuffer);\n          const text = parsed.text || '';\n          const numPages = parsed.numpages || 1;\n          \n          const mod = await import('pptxgenjs');\n          const PptxGenJS = mod.default || mod;\n          const pptx = new PptxGenJS();\n          \n          const lines = text.split('\\n').filter(l => l.trim());\n          const linesPerSlide = Math.max(1, Math.ceil(lines.length / numPages));\n          \n          for (let i = 0; i < numPages; i++) {\n            const slide = pptx.addSlide();\n            const slideLines = lines.slice(i * linesPerSlide, (i + 1) * linesPerSlide);\n            const slideText = slideLines.join('\\n') || `Slide ${i + 1}`;\n            slide.addText(slideText, { x: 0.5, y: 0.5, w: 9, h: 5, fontSize: 14, color: '000000' });\n          }\n          \n          outputBuffer = await pptx.write({ outputType: 'nodebuffer' });\n          outputBuffer = Buffer.isBuffer(outputBuffer) ? outputBuffer : Buffer.from(outputBuffer);\n          mime = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';\n        } catch {}\n      }\n\n      // PDF -> XLSX (basic table extraction)\n      if (!outputBuffer && lowerTarget === 'xlsx' && inputExt === 'pdf') {\n        try {\n          const parsed = await pdfParse(inputBuffer);\n          const text = parsed.text || '';\n          const lines = text.split('\\n').filter(l => l.trim());\n          \n          // Try to detect table structure (simple heuristic)\n          const rows = lines.map(line => {\n            // Try comma, tab, or multiple spaces as delimiters\n            if (line.includes('\\t')) return line.split('\\t');\n            if (line.includes(',')) return line.split(',').map(c => c.trim());\n            return line.split(/\\s{2,}/).filter(c => c.trim());\n          });\n          \n          const ws = XLSX.utils.aoa_to_sheet(rows);\n          const wb = XLSX.utils.book_new();\n          XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');\n          outputBuffer = Buffer.from(XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' }));\n          mime = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';\n        } catch {}\n      }\n\n      // PDF -> PDF/A (basic conversion - adds metadata)\n      if (!outputBuffer && (lowerTarget === 'pdfa' || lowerTarget === 'pdf-a') && inputExt === 'pdf') {\n        try {\n          // For true PDF/A, would need specialized library, but we can add basic metadata\n          // For now, return original PDF with PDF/A-like metadata\n          const doc = new PDFDocument({ autoFirstPage: false });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('error', () => {});\n          \n          // Copy pages from original PDF (simplified - would need pdf-lib for proper page copying)\n          doc.info({\n            Title: 'PDF/A Document',\n            Author: 'MegaPixelAI',\n            Subject: 'PDF/A compliant document',\n            Keywords: 'PDF/A',\n            Creator: 'MegaPixelAI Converter',\n            Producer: 'MegaPixelAI PDF/A Converter'\n          });\n          \n          // For now, return original with note that full PDF/A requires specialized processing\n          outputBuffer = inputBuffer;\n          mime = 'application/pdf';\n        } catch {}\n      }\n\n      // DOCX conversion\n      if (!outputBuffer && lowerTarget === 'docx') {\n        if (inputExt === 'docx') {\n          // DOCX → DOCX: pass-through\n          try {\n            outputBuffer = inputBuffer;\n            mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n          } catch (e) {\n            outputBuffer = inputBuffer;\n            mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n          }\n        } else if (inputExt === 'txt') {\n          // TXT → DOCX: crea un DOCX minimale dal testo\n          try {\n            // Usa mammoth per creare HTML, poi convertilo in DOCX via mammoth\n            // Mammoth può anche creare DOCX, ma è limitato. Per ora, convertiamo in HTML e poi in DOCX tramite ConvertAPI o lasciamo un placeholder\n            // Per una conversione nativa più robusta, servirebbe docx o officegen\n            // Fallback: restituisci un messaggio che indica che questa conversione richiede una libreria dedicata\n            const text = inputBuffer.toString('utf8');\n            // Creiamo un HTML minimale che mammoth può gestire\n            const html = `<html><body><p>${text.replace(/\\n/g, '</p><p>').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p></body></html>`;\n            // Per ora, mammoth non può creare DOCX da zero, quindi restituiamo l'originale\n            // In futuro, si potrebbe usare docx o officegen per creare DOCX nativamente\n            outputBuffer = Buffer.from('Conversione TXT → DOCX richiede una libreria dedicata. Per ora, usa TXT → HTML → DOCX tramite altri tool.', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('Errore nella conversione TXT → DOCX', 'utf8');\n            mime = 'text/plain';\n          }\n        } else if (inputExt === 'html' || inputExt === 'htm') {\n          // HTML → DOCX: mammoth non può creare DOCX, ma possiamo provare con altre librerie\n          // Per ora, restituiamo un messaggio\n          outputBuffer = Buffer.from('Conversione HTML → DOCX richiede una libreria dedicata (es. docx o officegen).', 'utf8');\n          mime = 'text/plain';\n        } else if (inputExt === 'md') {\n          // MD → DOCX: converti prima in HTML, poi cerca di convertire in DOCX\n          try {\n            const html = marked.parse(inputBuffer.toString('utf8'));\n            // Stessa situazione: mammoth non crea DOCX\n            outputBuffer = Buffer.from('Conversione MD → DOCX richiede una libreria dedicata. Converti prima in HTML.', 'utf8');\n            mime = 'text/plain';\n          } catch (e) {\n            outputBuffer = Buffer.from('Errore nella conversione MD → DOCX', 'utf8');\n            mime = 'text/plain';\n          }\n        }\n      }\n\n      // MD -> HTML/PDF (se non già gestito sopra)\n      if (!outputBuffer && (lowerTarget === 'html' || lowerTarget === 'pdf') && inputExt === 'md') {\n        const html = marked.parse(inputBuffer.toString('utf8'));\n        if (lowerTarget === 'html') {\n          outputBuffer = Buffer.from(html, 'utf8');\n          mime = 'text/html';\n        } else {\n          // Estrai testo dall'HTML e genera PDF con pdfkit\n          let text = html\n            .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n            .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n            .replace(/<[^>]+>/g, ' ')\n            .replace(/&nbsp;/g, ' ')\n            .replace(/&amp;/g, '&')\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&quot;/g, '\"')\n            .replace(/&#39;/g, \"'\")\n            .replace(/\\s+/g, ' ')\n            .trim();\n          \n          const doc = new PDFDocument({ margin: 48 });\n          const chunks = [];\n          doc.on('data', d => chunks.push(d));\n          doc.on('end', () => {});\n          doc.fontSize(12).text(text);\n          doc.end();\n          await new Promise(resolve => doc.on('end', resolve));\n          outputBuffer = Buffer.concat(chunks);\n          mime = 'application/pdf';\n        }\n      }\n\n      // ZIP (package the input file)\n      if (!outputBuffer && lowerTarget === 'zip') {\n        const zip = new JSZip();\n        zip.file(originalName, inputBuffer);\n        outputBuffer = await zip.generateAsync({ type: 'nodebuffer' });\n        mime = 'application/zip';\n      }\n\n      // ZIP extraction -> TGZ repack (single-file API)\n      if (!outputBuffer && (lowerTarget === 'tgz' || lowerTarget === 'tar' || lowerTarget === 'gz') && inputExt === 'zip') {\n        const zip = await JSZip.loadAsync(inputBuffer);\n        // Build a tar from all entries\n        const pack = tarStream.pack();\n        const tarChunks = [];\n        const finalizePack = async () => {\n          pack.finalize();\n          for await (const c of pack) tarChunks.push(c);\n          return Buffer.concat(tarChunks);\n        };\n        const entries = Object.keys(zip.files);\n        for (const name of entries) {\n          const entry = zip.files[name];\n          if (entry.dir) continue;\n          const fileBuf = await entry.async('nodebuffer');\n          pack.entry({ name, size: fileBuf.length }, fileBuf);\n        }\n        const tarBuf = await finalizePack();\n        if (lowerTarget === 'tar') {\n          outputBuffer = tarBuf;\n          mime = 'application/x-tar';\n        } else if (lowerTarget === 'gz' || lowerTarget === 'tgz') {\n          outputBuffer = zlib.gzipSync(tarBuf);\n          mime = 'application/gzip';\n        }\n      }\n\n      // 7Z creation using bundled 7z binary\n      if (!outputBuffer && lowerTarget === '7z') {\n        const tmpDir = path.dirname(inputPath);\n        const inFile = path.join(tmpDir, `in_${Date.now()}_${originalName}`);\n        fs.writeFileSync(inFile, inputBuffer);\n        const outPath = path.join(tmpDir, `out_${Date.now()}.7z`);\n        await new Promise((resolve, reject) => {\n          execFile(path7za, ['a', outPath, inFile], (err) => {\n            if (err) reject(err); else resolve();\n          });\n        });\n        outputBuffer = fs.readFileSync(outPath);\n        try { fs.unlinkSync(inFile); fs.unlinkSync(outPath); } catch {}\n        mime = 'application/x-7z-compressed';\n      }\n      // Generic archive extraction via 7z, repack to ZIP/TGZ\n      const extractable = ['7z','rar','tar','gz','tgz','zip','bz2','xz'];\n      if (!outputBuffer && extractable.includes(inputExt) && (lowerTarget === 'zip' || lowerTarget === 'tgz')) {\n        const tmpDir = path.dirname(inputPath);\n        const inPath = path.join(tmpDir, `in_${Date.now()}.${inputExt}`);\n        fs.writeFileSync(inPath, inputBuffer);\n        const outDir = path.join(tmpDir, `ext_${Date.now()}`);\n        fs.mkdirSync(outDir);\n        let extracted = false;\n        try {\n          await new Promise((resolve, reject) => {\n            execFile(path7za, ['x', inPath, `-o${outDir}`, '-y'], (err) => {\n              if (err) reject(err); else resolve();\n            });\n          });\n          extracted = true;\n        } catch {}\n        if (!extracted && inputExt === 'rar') {\n          try {\n            const extractor = await createExtractorFromData({ data: inputBuffer });\n            const list = extractor.extract();\n            for (const entry of list.files) {\n              if (entry.type === 'file') {\n                const outPathFile = path.join(outDir, entry.fileHeader.name);\n                const outSub = path.dirname(outPathFile);\n                fs.mkdirSync(outSub, { recursive: true });\n                fs.writeFileSync(outPathFile, Buffer.from(entry.extract()));\n              }\n            }\n            extracted = true;\n          } catch {}\n        }\n        if (extracted) {\n          if (lowerTarget === 'zip') {\n            const zip = new JSZip();\n            const addDir = (dir, base = '') => {\n              const items = fs.readdirSync(dir, { withFileTypes: true });\n              for (const it of items) {\n                const p = path.join(dir, it.name);\n                const rel = path.join(base, it.name);\n                if (it.isDirectory()) addDir(p, rel);\n                else zip.file(rel.replace(/\\\\/g, '/'), fs.readFileSync(p));\n              }\n            };\n            addDir(outDir);\n            outputBuffer = await zip.generateAsync({ type: 'nodebuffer' });\n            mime = 'application/zip';\n          } else {\n            const pack = tarStream.pack();\n            const tarChunks = [];\n            const addDir = (dir, base = '') => {\n              const items = fs.readdirSync(dir, { withFileTypes: true });\n              for (const it of items) {\n                const p = path.join(dir, it.name);\n                const rel = path.join(base, it.name);\n                if (it.isDirectory()) addDir(p, rel);\n                else pack.entry({ name: rel.replace(/\\\\/g, '/'), size: fs.statSync(p).size }, fs.readFileSync(p));\n              }\n            };\n            addDir(outDir);\n            pack.finalize();\n            for await (const c of pack) tarChunks.push(c);\n            const tarBuf2 = Buffer.concat(tarChunks);\n            outputBuffer = zlib.gzipSync(tarBuf2);\n            mime = 'application/gzip';\n          }\n        }\n        try { fs.rmSync(outDir, { recursive: true, force: true }); fs.unlinkSync(inPath); } catch {}\n      }\n\n      // TAR/GZ/TGZ creation from single file\n      if (!outputBuffer && lowerTarget === 'tar') {\n        const pack = tarStream.pack();\n        const chunks = [];\n        pack.entry({ name: originalName, size: inputBuffer.length }, inputBuffer);\n        pack.finalize();\n        for await (const c of pack) chunks.push(c);\n        outputBuffer = Buffer.concat(chunks);\n        mime = 'application/x-tar';\n      }\n      if (!outputBuffer && (lowerTarget === 'gz' || lowerTarget === 'tgz')) {\n        const tarBuf = lowerTarget === 'tgz' ? (() => {\n          const p = tarStream.pack();\n          const arr = [];\n          p.entry({ name: originalName, size: inputBuffer.length }, inputBuffer);\n          p.finalize();\n          return new Promise(async resolve => {\n            for await (const c of p) arr.push(c);\n            resolve(Buffer.concat(arr));\n          });\n        })() : Promise.resolve(inputBuffer);\n        const src = await tarBuf;\n        outputBuffer = zlib.gzipSync(src);\n        mime = 'application/gzip';\n      }\n\n      // FONT: TTF -> WOFF/WOFF2\n      if (!outputBuffer && (lowerTarget === 'woff' || lowerTarget === 'woff2') && inputExt === 'ttf') {\n        if (lowerTarget === 'woff') {\n          const { buffer } = ttf2woff(new Uint8Array(inputBuffer));\n          outputBuffer = Buffer.from(buffer);\n          mime = 'font/woff';\n        } else {\n          const buf = ttf2woff2(inputBuffer);\n          outputBuffer = Buffer.from(buf);\n          mime = 'font/woff2';\n        }\n      }\n      // FONT: TTF -> EOT\n      if (!outputBuffer && lowerTarget === 'eot' && inputExt === 'ttf') {\n        const eot = ttf2eotConv(new Uint8Array(inputBuffer)).buffer;\n        outputBuffer = Buffer.from(eot);\n        mime = 'application/vnd.ms-fontobject';\n      }\n\n      // SVG → PNG\n      if (!outputBuffer && (lowerTarget === 'png') && inputExt === 'svg') {\n        outputBuffer = await sharp(inputBuffer).png().toBuffer();\n        mime = 'image/png';\n      }\n      // PDF -> PNG/JPG (specific page) via sharp if supported\n      if (!outputBuffer && (lowerTarget === 'png' || lowerTarget === 'jpg' || lowerTarget === 'jpeg') && inputExt === 'pdf') {\n        try {\n          const p = Number.isFinite(page) && page >= 0 ? page : 0;\n          const raster = sharp(inputBuffer, { density: 150, page: p });\n          if (lowerTarget === 'png') {\n            outputBuffer = await raster.png().toBuffer();\n            mime = 'image/png';\n          } else {\n            outputBuffer = await raster.jpeg({ quality }).toBuffer();\n            mime = 'image/jpeg';\n          }\n        } catch {}\n      }\n\n      // SVGZ -> SVG\n      if (!outputBuffer && lowerTarget === 'svg' && inputExt === 'svgz') {\n        outputBuffer = zlib.gunzipSync(inputBuffer);\n        mime = 'image/svg+xml';\n      }\n\n      // CBZ from image or HTMLZ/TXTZ from text/html\n      if (!outputBuffer && (lowerTarget === 'cbz' || lowerTarget === 'htmlz' || lowerTarget === 'txtz')) {\n        const zip = new JSZip();\n        if (lowerTarget === 'cbz') {\n          // Pack single image as page01\n          zip.file('page01' + (path.extname(originalName) || '.jpg'), inputBuffer);\n        } else if (lowerTarget === 'htmlz') {\n          const html = inputExt === 'md' ? marked.parse(inputBuffer.toString('utf8')) : inputBuffer.toString('utf8');\n          zip.file('index.html', html);\n        } else if (lowerTarget === 'txtz') {\n          const txt = inputBuffer.toString('utf8');\n          zip.file('index.txt', txt);\n        }\n        outputBuffer = await zip.generateAsync({ type: 'nodebuffer' });\n        mime = 'application/zip';\n      }\n\n      // JAR (zip with .jar extension)\n      if (!outputBuffer && lowerTarget === 'jar') {\n        const zip = new JSZip();\n        zip.file(originalName, inputBuffer);\n        outputBuffer = await zip.generateAsync({ type: 'nodebuffer' });\n        mime = 'application/java-archive';\n      }\n\n      // EPUB from HTML/MD/TXT (single chapter)\n      if (!outputBuffer && lowerTarget === 'epub' && ['html','htm','md','txt'].includes(inputExt)) {\n        const html = inputExt === 'md' ? marked.parse(inputBuffer.toString('utf8'))\n                    : inputExt === 'txt' ? `<pre>${inputBuffer.toString('utf8')}</pre>`\n                    : inputBuffer.toString('utf8');\n        const tmpOut = path.join(path.dirname(inputPath), `out_${Date.now()}.epub`);\n        await new Epub({\n          title: path.basename(originalName, path.extname(originalName)),\n          author: 'MegaPixelAI',\n          content: [{ title: 'Chapter 1', data: html }]\n        }, tmpOut).promise;\n        outputBuffer = fs.readFileSync(tmpOut);\n        try { fs.unlinkSync(tmpOut); } catch {}\n        mime = 'application/epub+zip';\n      }\n\n      // If still not handled, return original buffer but with forced extension\n      if (!outputBuffer && !inputBuffer) {\n        return handleApiError(\n          new ProcessingError('Nessun buffer disponibile per la conversione'),\n          res,\n          {\n            method: req.method,\n            url: req.url,\n            endpoint: '/api/convert/[target]',\n            target,\n            inputExt,\n          }\n        );\n      }\n      \n      const finalBuffer = outputBuffer || inputBuffer;\n      \n      // Se non abbiamo un buffer di output specifico, significa che la conversione non è stata gestita\n      // In questo caso, per i documenti, proviamo a fare un pass-through intelligente\n      if (!outputBuffer && finalBuffer === inputBuffer) {\n        // Se l'estensione di input corrisponde al target, è un pass-through\n        if (inputExt === lowerTarget) {\n          // Pass-through: mantieni il file originale ma cambia solo il nome\n          const name = finalizeName(originalName);\n          // Determina il MIME type corretto basandosi sull'estensione\n          const mimeMap = {\n            'txt': 'text/plain',\n            'html': 'text/html',\n            'htm': 'text/html',\n            'md': 'text/markdown',\n            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'pdf': 'application/pdf',\n            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n          };\n          const finalMime = mimeMap[lowerTarget] || mime || 'application/octet-stream';\n          const dataUrl = toDataUrl(finalBuffer, finalMime);\n          return res.status(200).json({ name, dataUrl });\n        } else {\n          // Conversione non supportata\n          console.warn(`Conversione non supportata: ${inputExt} → ${lowerTarget}`);\n          return handleApiError(\n            new ProcessingError(`Conversione non supportata: ${inputExt} → ${lowerTarget}. Questo formato non può essere convertito in ${lowerTarget}.`),\n            res,\n            {\n              method: req.method,\n              url: req.url,\n              endpoint: '/api/convert/[target]',\n              target,\n              inputExt,\n            }\n          );\n        }\n      }\n      \n      const name = finalizeName(originalName);\n      \n      // Verifica che il buffer non sia vuoto\n      if (!finalBuffer || finalBuffer.length === 0) {\n        return handleApiError(\n          new ProcessingError('Il file risultante è vuoto. Il formato potrebbe non essere supportato.'),\n          res,\n          {\n            method: req.method,\n            url: req.url,\n            endpoint: '/api/convert/[target]',\n            target,\n            inputExt,\n          }\n        );\n      }\n      \n      const dataUrl = toDataUrl(finalBuffer, mime);\n      return res.status(200).json({ name, dataUrl });\n    } catch (e) {\n      // Assicurati che inputExt sia sempre definito\n      const safeInputExt = inputExt || (file?.originalFilename ? path.extname(file.originalFilename).replace('.', '').toLowerCase() : '') || '';\n      \n      // Verifica che la risposta non sia già stata inviata\n      if (!res.headersSent) {\n        return handleApiError(\n          new ProcessingError('Conversion failed: ' + (e.message || 'Unknown error'), e),\n          res,\n          {\n            method: req.method,\n            url: req.url,\n            endpoint: '/api/convert/[target]',\n            target,\n            inputExt: safeInputExt,\n          }\n        );\n      }\n      \n      // Se la risposta è già stata inviata, logga solo l'errore\n      console.error('Error after response sent in convert API:', e);\n    }\n    } catch (callbackError) {\n        // Errore non gestito nel callback async di form.parse\n        console.error('Unhandled error in form.parse callback:', callbackError);\n        if (!res.headersSent) {\n          const safeInputExt = inputExt || (file?.originalFilename ? path.extname(file.originalFilename).replace('.', '').toLowerCase() : '') || '';\n          return handleApiError(\n            new ProcessingError('Error processing file: ' + (callbackError.message || 'Unknown error'), callbackError),\n            res,\n            {\n              method: req.method,\n              url: req.url,\n              endpoint: '/api/convert/[target]',\n              target,\n              inputExt: safeInputExt,\n            }\n          );\n        }\n      }\n    });\n  } catch (parseError) {\n    // Errore nella configurazione o inizializzazione di form.parse\n    console.error('Error in form.parse setup:', parseError);\n    if (!res.headersSent) {\n      return handleApiError(\n        new ProcessingError('File upload setup failed: ' + (parseError.message || 'Unknown error'), parseError),\n        res,\n        {\n          method: req.method,\n          url: req.url,\n          endpoint: '/api/convert/[target]',\n        }\n      );\n    }\n  }\n}\n","import type { NextApiResponse } from '../../types'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport { sendError } from '../../server/api-utils'\nimport { RouteKind } from '../../server/route-kind'\nimport type { Span } from '../../server/lib/trace/tracer'\nimport { PagesAPIRouteModule } from '../../server/route-modules/pages-api/module.compiled'\n\nimport { hoist } from './helpers'\n\n// Import the userland code.\nimport * as userland from 'VAR_USERLAND'\nimport { getTracer, SpanKind } from '../../server/lib/trace/tracer'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport type { InstrumentationOnRequestError } from '../../server/instrumentation/types'\nimport { addRequestMeta } from '../../server/request-meta'\n\n// Re-export the handler (should be the default export).\nexport default hoist(userland, 'default')\n\n// Re-export config.\nexport const config = hoist(userland, 'config')\n\n// Create and export the route module that will be consumed.\nconst routeModule = new PagesAPIRouteModule({\n  definition: {\n    kind: RouteKind.PAGES_API,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n  },\n  userland,\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil?: (prom: Promise<void>) => void\n  }\n): Promise<void> {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  }\n\n  const prepareResult = await routeModule.prepare(req, res, { srcPage })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return\n  }\n\n  const { query, params, prerenderManifest, routerServerContext } =\n    prepareResult\n\n  try {\n    const method = req.method || 'GET'\n    const tracer = getTracer()\n\n    const activeSpan = tracer.getActiveScopeSpan()\n    const onRequestError =\n      routeModule.instrumentationOnRequestError.bind(routeModule)\n\n    const invokeRouteModule = async (span?: Span) =>\n      routeModule\n        .render(req, res, {\n          query: {\n            ...query,\n            ...params,\n          },\n          params,\n          allowedRevalidateHeaderKeys: process.env\n            .__NEXT_ALLOWED_REVALIDATE_HEADERS as any as string[],\n          multiZoneDraftMode: Boolean(process.env.__NEXT_MULTI_ZONE_DRAFT_MODE),\n          trustHostHeader: process.env\n            .__NEXT_TRUST_HOST_HEADER as any as boolean,\n          // TODO: get this from from runtime env so manifest\n          // doesn't need to load\n          previewProps: prerenderManifest.preview,\n          propagateError: false,\n          dev: routeModule.isDev,\n          page: 'VAR_DEFINITION_PAGE',\n\n          internalRevalidate: routerServerContext?.revalidate,\n\n          onError: (...args: Parameters<InstrumentationOnRequestError>) =>\n            onRequestError(req, ...args),\n        })\n        .finally(() => {\n          if (!span) return\n\n          span.setAttributes({\n            'http.status_code': res.statusCode,\n            'next.rsc': false,\n          })\n\n          const rootSpanAttributes = tracer.getRootSpanAttributes()\n          // We were unable to get attributes, probably OTEL is not enabled\n          if (!rootSpanAttributes) {\n            return\n          }\n\n          if (\n            rootSpanAttributes.get('next.span_type') !==\n            BaseServerSpan.handleRequest\n          ) {\n            console.warn(\n              `Unexpected root span type '${rootSpanAttributes.get(\n                'next.span_type'\n              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n            )\n            return\n          }\n\n          const route = rootSpanAttributes.get('next.route')\n          if (route) {\n            const name = `${method} ${route}`\n\n            span.setAttributes({\n              'next.route': route,\n              'http.route': route,\n              'next.span_name': name,\n            })\n            span.updateName(name)\n          } else {\n            span.updateName(`${method} ${srcPage}`)\n          }\n        })\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await invokeRouteModule(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          invokeRouteModule\n        )\n      )\n    }\n  } catch (err) {\n    // we re-throw in dev to show the error overlay\n    if (routeModule.isDev) {\n      throw err\n    }\n    // this is technically an invariant as error handling\n    // should be done inside of api-resolver onError\n    sendError(res as NextApiResponse, 500, 'Internal Server Error')\n  } finally {\n    // We don't allow any waitUntil work in pages API routes currently\n    // so if callback is present return with resolved promise since no\n    // pending work\n    ctx.waitUntil?.(Promise.resolve())\n  }\n}\n"],"names":["sendError","RouteKind","PagesAPIRouteModule","hoist","userland","getTracer","SpanKind","BaseServerSpan","addRequestMeta","config","routeModule","definition","kind","PAGES_API","page","pathname","bundlePath","filename","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","query","params","prerenderManifest","routerServerContext","method","tracer","activeSpan","getActiveScopeSpan","onRequestError","instrumentationOnRequestError","bind","invokeRouteModule","span","render","allowedRevalidateHeaderKeys","__NEXT_ALLOWED_REVALIDATE_HEADERS","multiZoneDraftMode","Boolean","__NEXT_MULTI_ZONE_DRAFT_MODE","trustHostHeader","__NEXT_TRUST_HOST_HEADER","previewProps","preview","propagateError","dev","internalRevalidate","revalidate","onError","args","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","withPropagatedContext","headers","trace","spanName","SERVER","attributes","url","err"],"mappings":"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","ignoreList":[1]}