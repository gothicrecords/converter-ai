{"version":3,"sources":["../../../utils/upscale.js","../../../utils/advancedUpscaler.js","../../../utils/msrUpscaler.js","../../../pages/api/upscale.js","../../../node_modules/next/src/build/templates/pages-api.ts"],"sourcesContent":["import sharp from 'sharp';\r\nimport AdvancedUpscaler from './advancedUpscaler.js';\r\nimport MSRUpscaler from './msrUpscaler.js';\r\n\r\n/**\r\n * Upscale immagine usando Multi-Stage Super Resolution (MSR)\r\n * Implementa tecniche avanzate: edge-aware, high-frequency injection, texture synthesis\r\n */\r\nexport default async function upscaleImage(fileBuffer, targetScale = 4) {\r\n  try {\r\n    // Usa MSR Upscaler per risultati di qualità superiore\r\n    const msrUpscaler = new MSRUpscaler();\r\n    \r\n    // Usa upscaler avanzato per qualità 4K/8K\r\n    // Cerca sempre di raggiungere almeno 4K quando possibile\r\n    const metadata = await sharp(fileBuffer, { sequentialRead: true }).metadata();\r\n    const originalWidth = metadata.width || 0;\r\n    const originalHeight = metadata.height || 0;\r\n    const mp = (originalWidth * originalHeight) / 1e6;\r\n    \r\n    // Calcola il lato lungo\r\n    const longSide = Math.max(originalWidth, originalHeight);\r\n    \r\n    let upscaled;\r\n    \r\n    // Strategia MSR: sempre upscale a 4K se possibile, altrimenti almeno 4x\r\n    if (longSide < 1920) {\r\n      // Immagine piccola/HD: upscale a 4K (3840px lato lungo)\r\n      console.log(`[MSR] Upscaling small image (${originalWidth}x${originalHeight}) to 4K`);\r\n      upscaled = await msrUpscaler.upscaleTo4K(fileBuffer);\r\n    } else if (longSide < 3840) {\r\n      // Immagine HD/FHD: upscale a 4K o almeno 2x fino a 4K\r\n      const scaleTo4K = 3840 / longSide;\r\n      console.log(`[MSR] Upscaling HD image (${originalWidth}x${originalHeight}) to 4K (scale: ${scaleTo4K.toFixed(2)}x)`);\r\n      upscaled = await msrUpscaler.upscale(fileBuffer, scaleTo4K, 3840);\r\n    } else {\r\n      // Immagine già grande: upscale almeno 2x o fino a 8K se possibile\r\n      const scale = Math.max(2, Math.min(4, 7680 / longSide));\r\n      console.log(`[MSR] Upscaling large image (${originalWidth}x${originalHeight}) by ${scale.toFixed(2)}x`);\r\n      upscaled = await msrUpscaler.upscale(fileBuffer, scale, 7680);\r\n    }\r\n    \r\n    // Ritorna data URL (completamente locale, nessuna API esterna)\r\n    const base64 = upscaled.toString('base64');\r\n    return `data:image/jpeg;base64,${base64}`;\r\n  } catch (e) {\r\n    console.error('Upscale fallito:', e);\r\n    throw new Error(`Upscale failed: ${e?.message || e}`);\r\n  }\r\n}\r\n","import sharp from 'sharp';\r\n\r\n/**\r\n * Upscaler avanzato per immagini 4K/8K\r\n * Usa tecniche multi-pass, denoising e sharpening avanzato\r\n */\r\nclass AdvancedUpscaler {\r\n    constructor() {\r\n        this.maxDimension = 7680; // 8K\r\n    }\r\n\r\n    // Denoising avanzato prima dell'upscaling\r\n    async denoise(image) {\r\n        // Applica leggero blur per ridurre noise, poi sharpening mirato\r\n        return image\r\n            .blur(0.3) // Leggero blur per noise\r\n            .sharpen({\r\n                sigma: 0.5,\r\n                m1: 0.4,\r\n                m2: 0.2\r\n            });\r\n    }\r\n\r\n    // Upscaling multi-pass per qualità massima\r\n    async multiPassUpscale(image, targetWidth, targetHeight, passes = 3) {\r\n        const metadata = await image.metadata();\r\n        let currentWidth = metadata.width;\r\n        let currentHeight = metadata.height;\r\n        \r\n        let currentImage = image;\r\n        \r\n        // Calcola fattore di scala per passaggio\r\n        const totalScale = Math.max(\r\n            targetWidth / currentWidth,\r\n            targetHeight / currentHeight\r\n        );\r\n        const scalePerPass = Math.pow(totalScale, 1 / passes);\r\n        \r\n        for (let pass = 0; pass < passes; pass++) {\r\n            const nextWidth = Math.min(\r\n                Math.round(currentWidth * scalePerPass),\r\n                targetWidth\r\n            );\r\n            const nextHeight = Math.min(\r\n                Math.round(currentHeight * scalePerPass),\r\n                targetHeight\r\n            );\r\n            \r\n            // Usa kernel diverso per ogni passaggio\r\n            let kernel = sharp.kernel.lanczos3;\r\n            if (pass === 0) {\r\n                kernel = sharp.kernel.lanczos3; // Primo passaggio: massima qualità\r\n            } else if (pass === passes - 1) {\r\n                kernel = sharp.kernel.lanczos3; // Ultimo passaggio: massima qualità\r\n            } else {\r\n                kernel = sharp.kernel.lanczos2; // Passaggi intermedi: bilanciato\r\n            }\r\n            \r\n            // Resize con kernel ottimizzato\r\n            currentImage = currentImage.resize(nextWidth, nextHeight, {\r\n                kernel,\r\n                fit: 'fill',\r\n                withoutEnlargement: false\r\n            });\r\n            \r\n            // Sharpening progressivo migliorato (più aggressivo negli ultimi passaggi)\r\n            const sharpenIntensity = 0.4 + (pass / passes) * 0.5;\r\n            const sharpenParams = {\r\n                sigma: 0.5 + sharpenIntensity,\r\n                m1: 0.4 + (pass / passes) * 0.3,\r\n                m2: 0.2 + (pass / passes) * 0.2\r\n            };\r\n            \r\n            // Negli ultimi passaggi, aggiungi parametri avanzati per dettagli ultra-fini\r\n            if (pass >= passes - 2) {\r\n                sharpenParams.x1 = 2;\r\n                sharpenParams.y2 = 2;\r\n                sharpenParams.y3 = 2;\r\n            }\r\n            \r\n            currentImage = currentImage.sharpen(sharpenParams);\r\n            \r\n            // Converti a buffer per il prossimo passaggio\r\n            if (pass < passes - 1) {\r\n                const buffer = await currentImage.toBuffer();\r\n                currentImage = sharp(buffer, { sequentialRead: true });\r\n            }\r\n            \r\n            currentWidth = nextWidth;\r\n            currentHeight = nextHeight;\r\n        }\r\n        \r\n        return currentImage;\r\n    }\r\n\r\n    // Micro-ricostruzione pixel: edge enhancement e detail recovery\r\n    async microPixelReconstruction(image) {\r\n        let reconstructed = image;\r\n        \r\n        // Step 1: Edge detection e enhancement per ricostruire bordi netti\r\n        // Usa unsharp mask avanzato per migliorare i bordi\r\n        reconstructed = reconstructed.sharpen({\r\n            sigma: 0.5,\r\n            m1: 1.2,\r\n            m2: 0.8,\r\n            x1: 1,\r\n            y2: 1,\r\n            y3: 1\r\n        });\r\n        \r\n        // Step 2: Detail recovery usando contrasto locale\r\n        // Aumenta il contrasto locale per recuperare dettagli persi\r\n        reconstructed = reconstructed.normalise();\r\n        \r\n        // Step 3: Micro-sharpening per pixel-level detail\r\n        reconstructed = reconstructed.sharpen({\r\n            sigma: 0.3,\r\n            m1: 0.9,\r\n            m2: 0.5\r\n        });\r\n        \r\n        return reconstructed;\r\n    }\r\n    \r\n    // Miglioramento luce avanzato: exposure, brightness, contrast\r\n    async enhanceLighting(image) {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Auto-exposure adjustment\r\n        // Normalizza l'esposizione per bilanciare luci e ombre\r\n        enhanced = enhanced.normalise();\r\n        \r\n        // Step 2: Brightness adjustment intelligente\r\n        // Aumenta leggermente la luminosità senza sovraesporre\r\n        enhanced = enhanced.modulate({\r\n            brightness: 1.05,\r\n            saturation: 1.1,\r\n            hue: 0\r\n        });\r\n        \r\n        // Step 3: Contrast enhancement per profondità\r\n        // Aumenta il contrasto per dare profondità all'immagine\r\n        enhanced = enhanced.linear(1.08, -(128 * 0.08));\r\n        \r\n        // Step 4: Shadow/highlight recovery\r\n        // Usa gamma correction per recuperare dettagli in ombre e luci\r\n        enhanced = enhanced.gamma(1.1);\r\n        \r\n        return enhanced;\r\n    }\r\n    \r\n    // Applica enhancement finale per massima qualità 4K\r\n    async applyFinalEnhancement(image, quality = 'high') {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Miglioramento luce (exposure, brightness, contrast)\r\n        enhanced = await this.enhanceLighting(enhanced);\r\n        \r\n        // Step 2: Micro-ricostruzione pixel per dettagli ultra-fini\r\n        enhanced = await this.microPixelReconstruction(enhanced);\r\n        \r\n        // Step 3: Sharpening avanzato multi-pass per dettagli ultra-definiti\r\n        // Primo passaggio: sharpening generale\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 1.5,\r\n            m1: 0.8,\r\n            m2: 0.5,\r\n            x1: 2,\r\n            y2: 2,\r\n            y3: 2\r\n        });\r\n        \r\n        // Step 4: Enhancement locale per dettagli fini\r\n        // Usa unsharp mask per migliorare la nitidezza\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.8,\r\n            m1: 1.0,\r\n            m2: 0.6,\r\n            x1: 3,\r\n            y2: 3,\r\n            y3: 3\r\n        });\r\n        \r\n        // Step 5: Rimozione artefatti e compressione ottimale\r\n        // Usa JPEG con qualità massima per preservare dettagli\r\n        enhanced = enhanced.jpeg({\r\n            quality: 98,\r\n            chromaSubsampling: '4:4:4', // No chroma subsampling per massima qualità\r\n            mozjpeg: true,\r\n            trellisQuantisation: true,\r\n            overshootDeringing: true,\r\n            optimiseScans: true,\r\n            progressive: true\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    // Upscale principale con pipeline completa\r\n    async upscale(buffer, targetScale = 4, maxDimension = 7680) {\r\n        try {\r\n            const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n            const metadata = await input.metadata();\r\n            \r\n            const originalWidth = metadata.width || 0;\r\n            const originalHeight = metadata.height || 0;\r\n            \r\n            if (originalWidth === 0 || originalHeight === 0) {\r\n                throw new Error('Dimensioni immagine non valide');\r\n            }\r\n            \r\n            // Calcola dimensioni target\r\n            let targetWidth = Math.round(originalWidth * targetScale);\r\n            let targetHeight = Math.round(originalHeight * targetScale);\r\n            \r\n            // Limita a maxDimension\r\n            if (targetWidth > maxDimension || targetHeight > maxDimension) {\r\n                const scale = maxDimension / Math.max(targetWidth, targetHeight);\r\n                targetWidth = Math.round(targetWidth * scale);\r\n                targetHeight = Math.round(targetHeight * scale);\r\n            }\r\n            \r\n            console.log(`Upscaling: ${originalWidth}x${originalHeight} -> ${targetWidth}x${targetHeight}`);\r\n            \r\n            // Step 1: Denoising migliorato (applicato più spesso per immagini di qualità inferiore)\r\n            let processed = input;\r\n            const mp = (originalWidth * originalHeight) / 1e6;\r\n            // Applica denoising per immagini piccole o se la risoluzione è bassa\r\n            if (mp < 3 || Math.max(originalWidth, originalHeight) < 2000) {\r\n                processed = await this.denoise(processed);\r\n            }\r\n            \r\n            // Step 2: Multi-pass upscaling\r\n            const scaleFactor = Math.max(\r\n                targetWidth / originalWidth,\r\n                targetHeight / originalHeight\r\n            );\r\n            \r\n            // Determina numero di passaggi basato su scala (più passaggi = migliore qualità)\r\n            let passes = 3; // Default aumentato da 2 a 3\r\n            if (scaleFactor > 4) {\r\n                passes = 6; // Per upscaling molto grandi, usa più passaggi\r\n            } else if (scaleFactor > 3) {\r\n                passes = 5;\r\n            } else if (scaleFactor > 2) {\r\n                passes = 4;\r\n            }\r\n            \r\n            processed = await this.multiPassUpscale(\r\n                processed,\r\n                targetWidth,\r\n                targetHeight,\r\n                passes\r\n            );\r\n            \r\n            // Step 3: Enhancement finale (converte già a JPEG)\r\n            processed = await this.applyFinalEnhancement(processed, 'high');\r\n            \r\n            // L'enhancement finale restituisce già un'immagine processata, converti a buffer\r\n            const outputBuffer = await processed.toBuffer();\r\n            \r\n            console.log(`Upscale completato: ${(outputBuffer.length / 1024 / 1024).toFixed(2)} MB`);\r\n            \r\n            return outputBuffer;\r\n            \r\n        } catch (error) {\r\n            console.error('Errore upscaling avanzato:', error);\r\n            throw new Error(`Upscaling fallito: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    // Upscale a 4K (3840x2160 o lato lungo 3840)\r\n    async upscaleTo4K(buffer) {\r\n        const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n        const metadata = await input.metadata();\r\n        \r\n        const originalWidth = metadata.width || 0;\r\n        const originalHeight = metadata.height || 0;\r\n        \r\n        // Calcola dimensioni 4K mantenendo aspect ratio\r\n        const longSide = Math.max(originalWidth, originalHeight);\r\n        const scale = 3840 / longSide;\r\n        \r\n        const targetWidth = Math.round(originalWidth * scale);\r\n        const targetHeight = Math.round(originalHeight * scale);\r\n        \r\n        return this.upscale(buffer, scale, 3840);\r\n    }\r\n\r\n    // Upscale a 8K (7680x4320 o lato lungo 7680)\r\n    async upscaleTo8K(buffer) {\r\n        const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n        const metadata = await input.metadata();\r\n        \r\n        const originalWidth = metadata.width || 0;\r\n        const originalHeight = metadata.height || 0;\r\n        \r\n        // Calcola dimensioni 8K mantenendo aspect ratio\r\n        const longSide = Math.max(originalWidth, originalHeight);\r\n        const scale = 7680 / longSide;\r\n        \r\n        const targetWidth = Math.round(originalWidth * scale);\r\n        const targetHeight = Math.round(originalHeight * scale);\r\n        \r\n        return this.upscale(buffer, scale, 7680);\r\n    }\r\n}\r\n\r\nexport default AdvancedUpscaler;\r\n\r\n","import sharp from 'sharp';\r\n\r\n/**\r\n * Multi-Stage Super Resolution (MSR) Upscaler\r\n * Implementa una pipeline multi-stadio per upscaling di alta qualità\r\n */\r\nclass MSRUpscaler {\r\n    constructor() {\r\n        this.maxDimension = 7680; // 8K\r\n    }\r\n\r\n    /**\r\n     * Stage 1: Denoising + Deblurring\r\n     * Rimuove rumore e sfocatura prima dell'upscaling\r\n     */\r\n    async stage1_DenoiseDeblur(image) {\r\n        let processed = image;\r\n        \r\n        // Step 1: Denoising con median filter (preserva i bordi)\r\n        processed = processed.median(3);\r\n        \r\n        // Step 2: Deblurring con unsharp mask leggero\r\n        processed = processed.sharpen({\r\n            sigma: 0.3,\r\n            m1: 0.5,\r\n            m2: 0.3\r\n        });\r\n        \r\n        // Step 3: Bilateral-like filtering (simulato con blur selettivo)\r\n        // Sharp non ha convolve diretto, usiamo un approccio alternativo\r\n        // Applica un blur molto leggero seguito da sharpening per preservare i bordi\r\n        processed = processed.blur(0.5);\r\n        processed = processed.sharpen({\r\n            sigma: 0.2,\r\n            m1: 0.3,\r\n            m2: 0.15\r\n        });\r\n        \r\n        return processed;\r\n    }\r\n\r\n    /**\r\n     * Stage 2: Super Resolution x2 o x4\r\n     * Upscaling progressivo con kernel ottimizzati\r\n     */\r\n    async stage2_SuperResolution(image, targetScale, originalWidth, originalHeight) {\r\n        let currentImage = image;\r\n        let currentWidth = originalWidth;\r\n        let currentHeight = originalHeight;\r\n        \r\n        // Calcola il numero di passaggi necessari (ogni passaggio max 2x)\r\n        const totalPasses = Math.ceil(Math.log2(targetScale));\r\n        \r\n        for (let pass = 0; pass < totalPasses; pass++) {\r\n            const scaleThisPass = Math.min(2, targetScale / (Math.pow(2, pass)));\r\n            const nextWidth = Math.round(currentWidth * scaleThisPass);\r\n            const nextHeight = Math.round(currentHeight * scaleThisPass);\r\n            \r\n            // Usa Lanczos3 per massima qualità\r\n            currentImage = currentImage.resize(nextWidth, nextHeight, {\r\n                kernel: sharp.kernel.lanczos3,\r\n                fit: 'fill',\r\n                withoutEnlargement: false\r\n            });\r\n            \r\n            // Sharpening leggero dopo ogni passaggio\r\n            if (pass < totalPasses - 1) {\r\n                currentImage = currentImage.sharpen({\r\n                    sigma: 0.4,\r\n                    m1: 0.5,\r\n                    m2: 0.3\r\n                });\r\n            }\r\n            \r\n            // Converti a buffer per il prossimo passaggio\r\n            if (pass < totalPasses - 1) {\r\n                const buffer = await currentImage.toBuffer();\r\n                currentImage = sharp(buffer, { sequentialRead: true });\r\n            }\r\n            \r\n            currentWidth = nextWidth;\r\n            currentHeight = nextHeight;\r\n        }\r\n        \r\n        return currentImage;\r\n    }\r\n\r\n    /**\r\n     * Stage 3: Fine Detail + Intelligent Sharpening (non lineare)\r\n     * Enhancement intelligente che evita artefatti\r\n     */\r\n    async stage3_FineDetail(image) {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Edge-preserving sharpening\r\n        // Usa unsharp mask con parametri conservativi\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 1.0,\r\n            m1: 0.7,\r\n            m2: 0.4,\r\n            x1: 2,\r\n            y2: 2,\r\n            y3: 2\r\n        });\r\n        \r\n        // Step 2: Detail enhancement non lineare\r\n        // Applica contrasto locale per migliorare i dettagli senza artefatti\r\n        enhanced = enhanced.normalise();\r\n        \r\n        // Step 3: Micro-sharpening per dettagli fini\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.5,\r\n            m1: 0.8,\r\n            m2: 0.5\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    /**\r\n     * Edge-Aware Enhancement\r\n     * Riconosce e migliora bordi e contorni usando tecniche edge-preserving\r\n     */\r\n    async edgeAwareEnhancement(image) {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Edge-preserving sharpening\r\n        // Usa unsharp mask avanzato che preserva i bordi\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 1.2,\r\n            m1: 0.9,\r\n            m2: 0.6,\r\n            x1: 2,\r\n            y2: 2,\r\n            y3: 2\r\n        });\r\n        \r\n        // Step 2: Contrast enhancement per bordi più netti\r\n        // Aumenta il contrasto locale per evidenziare i bordi\r\n        enhanced = enhanced.linear(1.06, -(128 * 0.06));\r\n        \r\n        // Step 3: Normalizzazione per migliorare la definizione dei bordi\r\n        enhanced = enhanced.normalise();\r\n        \r\n        // Step 4: Sharpening mirato per bordi ultra-netti\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.8,\r\n            m1: 0.7,\r\n            m2: 0.5\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    /**\r\n     * High-Frequency Detail Injector\r\n     * Estrae e potenzia le alte frequenze (dettagli fini)\r\n     */\r\n    async highFrequencyInjector(image) {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Estrai alte frequenze usando sharpening avanzato\r\n        // Usa unsharp mask per evidenziare i dettagli fini\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.8,\r\n            m1: 1.0,\r\n            m2: 0.6,\r\n            x1: 3,\r\n            y2: 3,\r\n            y3: 3\r\n        });\r\n        \r\n        // Step 2: Potenzia le alte frequenze con contrasto locale\r\n        enhanced = enhanced.normalise();\r\n        \r\n        // Step 3: Enhancement mirato per dettagli ultra-fini\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.5,\r\n            m1: 0.8,\r\n            m2: 0.5\r\n        });\r\n        \r\n        // Step 4: Leggero boost di luminosità e saturazione\r\n        enhanced = enhanced.modulate({\r\n            brightness: 1.03,\r\n            saturation: 1.05\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    /**\r\n     * Color Space Enhancement\r\n     * Lavora in spazi colore ottimizzati per migliorare nitidezza\r\n     */\r\n    async colorSpaceEnhancement(image) {\r\n        let enhanced = image;\r\n        \r\n        // Step 1: Converti a LAB per lavorare sulla luminanza separatamente\r\n        // Sharp non supporta LAB direttamente, quindi usiamo RGB con canali separati\r\n        // Ma possiamo migliorare la luminanza con normalizzazione\r\n        \r\n        // Step 2: Normalizza la luminanza per migliorare i dettagli\r\n        enhanced = enhanced.normalise();\r\n        \r\n        // Step 3: Aumenta il contrasto nella luminanza\r\n        enhanced = enhanced.linear(1.05, -(128 * 0.05));\r\n        \r\n        // Step 4: Migliora la saturazione per colori più vividi\r\n        enhanced = enhanced.modulate({\r\n            saturation: 1.1,\r\n            brightness: 1.02,\r\n            hue: 0\r\n        });\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    /**\r\n     * Texture-Aware Processing\r\n     * Applica filtri diversi in base al tipo di texture\r\n     */\r\n    async textureAwareProcessing(image) {\r\n        let enhanced = image;\r\n        \r\n        // Per ora usiamo un approccio generale\r\n        // In futuro si può integrare segmentazione semantica\r\n        \r\n        // Step 1: Enhancement generale per texture\r\n        enhanced = enhanced.sharpen({\r\n            sigma: 0.6,\r\n            m1: 0.7,\r\n            m2: 0.4\r\n        });\r\n        \r\n        // Step 2: Contrasto locale per texture più definite\r\n        enhanced = enhanced.normalise();\r\n        \r\n        return enhanced;\r\n    }\r\n\r\n    /**\r\n     * Blind Degradation Modeling\r\n     * Rileva il tipo di degradazione e applica il trattamento appropriato\r\n     */\r\n    async detectDegradation(image) {\r\n        // Analizza l'immagine per determinare il tipo di degradazione\r\n        // Usiamo euristiche basate sui metadati\r\n        \r\n        const metadata = await image.metadata();\r\n        \r\n        // Estrai informazioni base\r\n        const width = metadata.width || 0;\r\n        const height = metadata.height || 0;\r\n        const hasAlpha = metadata.hasAlpha || false;\r\n        const format = metadata.format || '';\r\n        \r\n        // Determina il tipo di degradazione basandosi su caratteristiche dell'immagine\r\n        let degradationType = 'unknown';\r\n        \r\n        // Bassa risoluzione\r\n        if (width < 1000 && height < 1000) {\r\n            degradationType = 'low_res';\r\n        }\r\n        // Compressione JPEG (spesso ha dimensioni file piccole rispetto alla risoluzione)\r\n        else if (format === 'jpeg' && width * height > 500000 && width * height < 2000000) {\r\n            degradationType = 'compression';\r\n        }\r\n        // Rumore (immagini scure o con molti dettagli)\r\n        else if (width * height < 500000) {\r\n            degradationType = 'noise';\r\n        }\r\n        // Sfocatura (immagini più grandi ma con dettagli persi)\r\n        else {\r\n            degradationType = 'blur';\r\n        }\r\n        \r\n        return degradationType;\r\n    }\r\n\r\n    /**\r\n     * Pipeline principale MSR\r\n     */\r\n    async upscale(buffer, targetScale = 4, maxDimension = 7680) {\r\n        try {\r\n            const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n            const metadata = await input.metadata();\r\n            \r\n            const originalWidth = metadata.width || 0;\r\n            const originalHeight = metadata.height || 0;\r\n            \r\n            if (originalWidth === 0 || originalHeight === 0) {\r\n                throw new Error('Dimensioni immagine non valide');\r\n            }\r\n            \r\n            // Calcola dimensioni target\r\n            let targetWidth = Math.round(originalWidth * targetScale);\r\n            let targetHeight = Math.round(originalHeight * targetScale);\r\n            \r\n            // Limita a maxDimension\r\n            if (targetWidth > maxDimension || targetHeight > maxDimension) {\r\n                const scale = maxDimension / Math.max(targetWidth, targetHeight);\r\n                targetWidth = Math.round(targetWidth * scale);\r\n                targetHeight = Math.round(targetHeight * scale);\r\n            }\r\n            \r\n            console.log(`[MSR] Upscaling: ${originalWidth}x${originalHeight} -> ${targetWidth}x${targetHeight}`);\r\n            \r\n            // Rileva tipo di degradazione\r\n            const degradationType = await this.detectDegradation(input);\r\n            console.log(`[MSR] Detected degradation type: ${degradationType}`);\r\n            \r\n            // Stage 1: Denoising + Deblurring\r\n            console.log('[MSR] Stage 1: Denoising + Deblurring...');\r\n            let processed = await this.stage1_DenoiseDeblur(input);\r\n            \r\n            // Stage 2: Super Resolution\r\n            const actualScale = Math.max(targetWidth / originalWidth, targetHeight / originalHeight);\r\n            console.log(`[MSR] Stage 2: Super Resolution (${actualScale.toFixed(2)}x)...`);\r\n            processed = await this.stage2_SuperResolution(processed, actualScale, originalWidth, originalHeight);\r\n            \r\n            // Stage 3: Fine Detail + Intelligent Sharpening\r\n            console.log('[MSR] Stage 3: Fine Detail Enhancement...');\r\n            processed = await this.stage3_FineDetail(processed);\r\n            \r\n            // Edge-Aware Enhancement\r\n            console.log('[MSR] Edge-Aware Enhancement...');\r\n            processed = await this.edgeAwareEnhancement(processed);\r\n            \r\n            // High-Frequency Detail Injector\r\n            console.log('[MSR] High-Frequency Detail Injection...');\r\n            processed = await this.highFrequencyInjector(processed);\r\n            \r\n            // Color Space Enhancement\r\n            console.log('[MSR] Color Space Enhancement...');\r\n            processed = await this.colorSpaceEnhancement(processed);\r\n            \r\n            // Texture-Aware Processing\r\n            console.log('[MSR] Texture-Aware Processing...');\r\n            processed = await this.textureAwareProcessing(processed);\r\n            \r\n            // Output finale con qualità massima\r\n            const outputBuffer = await processed\r\n                .jpeg({\r\n                    quality: 98,\r\n                    chromaSubsampling: '4:4:4',\r\n                    mozjpeg: true,\r\n                    trellisQuantisation: true,\r\n                    overshootDeringing: true,\r\n                    optimiseScans: true,\r\n                    progressive: true\r\n                })\r\n                .toBuffer();\r\n            \r\n            console.log(`[MSR] Upscale completato: ${(outputBuffer.length / 1024 / 1024).toFixed(2)} MB`);\r\n            \r\n            return outputBuffer;\r\n            \r\n        } catch (error) {\r\n            console.error('[MSR] Errore upscaling:', error);\r\n            throw new Error(`MSR Upscaling fallito: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Upscale a 4K usando MSR\r\n     */\r\n    async upscaleTo4K(buffer) {\r\n        const input = sharp(buffer, { sequentialRead: true }).rotate();\r\n        const metadata = await input.metadata();\r\n        \r\n        const originalWidth = metadata.width || 0;\r\n        const originalHeight = metadata.height || 0;\r\n        const longSide = Math.max(originalWidth, originalHeight);\r\n        const scale = 3840 / longSide;\r\n        \r\n        return this.upscale(buffer, scale, 3840);\r\n    }\r\n}\r\n\r\nexport default MSRUpscaler;\r\n\r\n","import formidable from 'formidable';\r\nimport fs from 'fs/promises';\r\nimport upscaleImage from '../../utils/upscale.js';\r\nimport { enhanceImageQualityWithAI } from '../../lib/openai.js';\r\nimport { \r\n  handleApiError, \r\n  ValidationError, \r\n  FileTooLargeError, \r\n  InvalidFileTypeError,\r\n  TimeoutError,\r\n  ProcessingError,\r\n  FileSystemError\r\n} from '../../errors';\r\nimport { canUseTool, getUpgradeMessage } from '../../lib/usage-limits.js';\r\nimport { getUsageStats, incrementUsage, getUserPlan, getUserId } from '../../lib/usage-tracker.js';\r\n\r\nexport const config = {\r\n  api: {\r\n    bodyParser: false,\r\n  },\r\n};\r\n\r\nexport default async function handler(req, res) {\r\n  // Handle CORS preflight\r\n  if (req.method === 'OPTIONS') {\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    res.status(200).end();\r\n    return;\r\n  }\r\n\r\n  if (req.method !== 'POST') {\r\n    res.setHeader('Allow', 'POST');\r\n    return res.status(405).json({ error: 'Method not allowed', code: 'METHOD_NOT_ALLOWED' });\r\n  }\r\n\r\n  // Set timeout for long-running operations\r\n  const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB\r\n  const TIMEOUT_MS = 120000; // 2 minutes\r\n\r\n  // Su Vercel, usa /tmp (unico filesystem scrivibile)\r\n  const tmpDir = process.env.VERCEL ? '/tmp' : os.tmpdir();\r\n\r\n  const form = formidable({ \r\n    multiples: false,\r\n    maxFileSize: MAX_FILE_SIZE,\r\n    keepExtensions: true,\r\n    uploadDir: tmpDir, // Usa /tmp su Vercel\r\n  });\r\n\r\n  let filePath = null;\r\n\r\n  try {\r\n    // Support both callback and promise styles robustly\r\n    const parsed = await Promise.race([\r\n      new Promise((resolve, reject) => {\r\n        form.parse(req, (err, fields, files) => {\r\n          if (err) {\r\n            // Handle formidable-specific errors\r\n            if (err.code === 'LIMIT_FILE_SIZE') {\r\n              return reject(new FileTooLargeError(MAX_FILE_SIZE));\r\n            }\r\n            return reject(new ValidationError('File upload failed: ' + err.message, err));\r\n          }\r\n          resolve({ fields, files });\r\n        });\r\n      }),\r\n      new Promise((_, reject) => \r\n        setTimeout(() => reject(new TimeoutError('Request timeout', TIMEOUT_MS)), TIMEOUT_MS)\r\n      )\r\n    ]);\r\n\r\n    const { files } = parsed;\r\n\r\n    // Accept 'image' or 'file' field names; normalize array/single\r\n    let file = files?.image ?? files?.file ?? null;\r\n    if (Array.isArray(file)) file = file[0];\r\n\r\n    if (!file) {\r\n      throw new ValidationError('No file uploaded');\r\n    }\r\n\r\n    // Validate file type\r\n    if (!file.mimetype?.startsWith('image/')) {\r\n      throw new InvalidFileTypeError(['image/jpeg', 'image/png', 'image/webp', 'image/gif']);\r\n    }\r\n\r\n    // Validate file size\r\n    if (file.size > MAX_FILE_SIZE) {\r\n      throw new FileTooLargeError(MAX_FILE_SIZE, file.size);\r\n    }\r\n\r\n    // Verifica limiti d'uso (tool PRO)\r\n    const userId = getUserId(req);\r\n    const userPlan = getUserPlan(req);\r\n    const toolSlug = 'upscaler-ai';\r\n    const usageStats = getUsageStats(userId, toolSlug);\r\n    const fileInfo = {\r\n      size: file.size,\r\n    };\r\n\r\n    const limitCheck = canUseTool(toolSlug, userPlan, usageStats, fileInfo);\r\n    \r\n    if (!limitCheck.allowed) {\r\n      // Cleanup file prima di ritornare errore\r\n      if (filePath) {\r\n        try { \r\n          await fs.unlink(filePath);\r\n        } catch (cleanupError) {\r\n          console.warn('Failed to cleanup temp file:', cleanupError);\r\n        }\r\n      }\r\n      \r\n      return res.status(403).json({\r\n        error: limitCheck.reason,\r\n        limitType: limitCheck.limitType,\r\n        current: limitCheck.current,\r\n        max: limitCheck.max,\r\n        upgradeMessage: getUpgradeMessage(toolSlug, userPlan),\r\n        requiresPro: true,\r\n      });\r\n    }\r\n\r\n    filePath = file.filepath || file.path; // v3 vs older\r\n    if (!filePath) {\r\n      throw new ValidationError('Uploaded file path missing');\r\n    }\r\n\r\n    let buffer;\r\n    try {\r\n      buffer = await fs.readFile(filePath);\r\n    } catch (readError) {\r\n      throw new FileSystemError('Failed to read uploaded file', readError);\r\n    }\r\n    \r\n    // Validate buffer is not empty\r\n    if (!buffer || buffer.length === 0) {\r\n      throw new ValidationError('File is empty or corrupted');\r\n    }\r\n\r\n    let upscaledUrl;\r\n    try {\r\n      // Use advanced local upscaler as primary method (improves existing image quality)\r\n      console.log('Using advanced local upscaler to enhance image quality');\r\n      upscaledUrl = await upscaleImage(buffer);\r\n      \r\n      // Optional: If OpenAI API key is available, use it for additional quality enhancement\r\n      // This analyzes the image and applies AI-based improvements\r\n      if (process.env.OPENAI_API_KEY) {\r\n        try {\r\n          console.log('Applying AI-based quality enhancement with OpenAI Vision...');\r\n          const enhancedBuffer = await enhanceImageQualityWithAI(buffer, file.mimetype);\r\n          \r\n          // Convert enhanced buffer to data URL\r\n          const base64 = enhancedBuffer.toString('base64');\r\n          upscaledUrl = `data:${file.mimetype || 'image/jpeg'};base64,${base64}`;\r\n          \r\n          console.log('AI enhancement applied successfully');\r\n        } catch (aiError) {\r\n          console.warn('AI enhancement failed, using upscaled result:', aiError.message);\r\n          // Continue with upscaled result if AI enhancement fails\r\n        }\r\n      }\r\n      \r\n      // Incrementa contatore uso (solo se la richiesta è andata a buon fine)\r\n      incrementUsage(userId, toolSlug);\r\n      \r\n      // Cleanup temp file\r\n      if (filePath) {\r\n        try { \r\n          await fs.unlink(filePath);\r\n          filePath = null;\r\n        } catch (cleanupError) {\r\n          console.warn('Failed to cleanup temp file:', cleanupError);\r\n        }\r\n      }\r\n      \r\n      return res.status(200).json({ url: upscaledUrl });\r\n    } catch (upscaleError) {\r\n      throw new ProcessingError('Failed to upscale image', upscaleError);\r\n    }\r\n\r\n  } catch (error) {\r\n    // Cleanup on error\r\n    if (filePath) {\r\n      try { \r\n        await fs.unlink(filePath);\r\n      } catch (cleanupError) {\r\n        console.warn('Failed to cleanup temp file on error:', cleanupError);\r\n      }\r\n    }\r\n\r\n    // Use centralized error handler\r\n    handleApiError(error, res, {\r\n      method: req.method,\r\n      url: req.url,\r\n      endpoint: '/api/upscale',\r\n    });\r\n  }\r\n}\r\n","import type { NextApiResponse } from '../../types'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\n\nimport { sendError } from '../../server/api-utils'\nimport { RouteKind } from '../../server/route-kind'\nimport type { Span } from '../../server/lib/trace/tracer'\nimport { PagesAPIRouteModule } from '../../server/route-modules/pages-api/module.compiled'\n\nimport { hoist } from './helpers'\n\n// Import the userland code.\nimport * as userland from 'VAR_USERLAND'\nimport { getTracer, SpanKind } from '../../server/lib/trace/tracer'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport type { InstrumentationOnRequestError } from '../../server/instrumentation/types'\nimport { addRequestMeta } from '../../server/request-meta'\n\n// Re-export the handler (should be the default export).\nexport default hoist(userland, 'default')\n\n// Re-export config.\nexport const config = hoist(userland, 'config')\n\n// Create and export the route module that will be consumed.\nconst routeModule = new PagesAPIRouteModule({\n  definition: {\n    kind: RouteKind.PAGES_API,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    // The following aren't used in production.\n    bundlePath: '',\n    filename: '',\n  },\n  userland,\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n})\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil?: (prom: Promise<void>) => void\n  }\n): Promise<void> {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  }\n\n  const prepareResult = await routeModule.prepare(req, res, { srcPage })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return\n  }\n\n  const { query, params, prerenderManifest, routerServerContext } =\n    prepareResult\n\n  try {\n    const method = req.method || 'GET'\n    const tracer = getTracer()\n\n    const activeSpan = tracer.getActiveScopeSpan()\n    const onRequestError =\n      routeModule.instrumentationOnRequestError.bind(routeModule)\n\n    const invokeRouteModule = async (span?: Span) =>\n      routeModule\n        .render(req, res, {\n          query: {\n            ...query,\n            ...params,\n          },\n          params,\n          allowedRevalidateHeaderKeys: process.env\n            .__NEXT_ALLOWED_REVALIDATE_HEADERS as any as string[],\n          multiZoneDraftMode: Boolean(process.env.__NEXT_MULTI_ZONE_DRAFT_MODE),\n          trustHostHeader: process.env\n            .__NEXT_TRUST_HOST_HEADER as any as boolean,\n          // TODO: get this from from runtime env so manifest\n          // doesn't need to load\n          previewProps: prerenderManifest.preview,\n          propagateError: false,\n          dev: routeModule.isDev,\n          page: 'VAR_DEFINITION_PAGE',\n\n          internalRevalidate: routerServerContext?.revalidate,\n\n          onError: (...args: Parameters<InstrumentationOnRequestError>) =>\n            onRequestError(req, ...args),\n        })\n        .finally(() => {\n          if (!span) return\n\n          span.setAttributes({\n            'http.status_code': res.statusCode,\n            'next.rsc': false,\n          })\n\n          const rootSpanAttributes = tracer.getRootSpanAttributes()\n          // We were unable to get attributes, probably OTEL is not enabled\n          if (!rootSpanAttributes) {\n            return\n          }\n\n          if (\n            rootSpanAttributes.get('next.span_type') !==\n            BaseServerSpan.handleRequest\n          ) {\n            console.warn(\n              `Unexpected root span type '${rootSpanAttributes.get(\n                'next.span_type'\n              )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n            )\n            return\n          }\n\n          const route = rootSpanAttributes.get('next.route')\n          if (route) {\n            const name = `${method} ${route}`\n\n            span.setAttributes({\n              'next.route': route,\n              'http.route': route,\n              'next.span_name': name,\n            })\n            span.updateName(name)\n          } else {\n            span.updateName(`${method} ${srcPage}`)\n          }\n        })\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await invokeRouteModule(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          invokeRouteModule\n        )\n      )\n    }\n  } catch (err) {\n    // we re-throw in dev to show the error overlay\n    if (routeModule.isDev) {\n      throw err\n    }\n    // this is technically an invariant as error handling\n    // should be done inside of api-resolver onError\n    sendError(res as NextApiResponse, 500, 'Internal Server Error')\n  } finally {\n    // We don't allow any waitUntil work in pages API routes currently\n    // so if callback is present return with resolved promise since no\n    // pending work\n    ctx.waitUntil?.(Promise.resolve())\n  }\n}\n"],"names":["sendError","RouteKind","PagesAPIRouteModule","hoist","userland","getTracer","SpanKind","BaseServerSpan","addRequestMeta","config","routeModule","definition","kind","PAGES_API","page","pathname","bundlePath","filename","distDir","process","env","__NEXT_RELATIVE_DIST_DIR","relativeProjectDir","__NEXT_RELATIVE_PROJECT_DIR","handler","req","res","ctx","isDev","hrtime","bigint","srcPage","TURBOPACK","replace","prepareResult","prepare","statusCode","end","waitUntil","Promise","resolve","query","params","prerenderManifest","routerServerContext","method","tracer","activeSpan","getActiveScopeSpan","onRequestError","instrumentationOnRequestError","bind","invokeRouteModule","span","render","allowedRevalidateHeaderKeys","__NEXT_ALLOWED_REVALIDATE_HEADERS","multiZoneDraftMode","Boolean","__NEXT_MULTI_ZONE_DRAFT_MODE","trustHostHeader","__NEXT_TRUST_HOST_HEADER","previewProps","preview","propagateError","dev","internalRevalidate","revalidate","onError","args","finally","setAttributes","rootSpanAttributes","getRootSpanAttributes","get","handleRequest","console","warn","route","name","updateName","withPropagatedContext","headers","trace","spanName","SERVER","attributes","url","err"],"mappings":"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","ignoreList":[4]}